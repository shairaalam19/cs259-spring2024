diff --git a/hw/rtl/VX_define.vh b/hw/rtl/VX_define.vh
index 477129a..082aacb 100644
--- a/hw/rtl/VX_define.vh
+++ b/hw/rtl/VX_define.vh
@@ -135,7 +135,7 @@
 `define INST_ALU_OR          4'b1101
 `define INST_ALU_XOR         4'b1110
 `define INST_ALU_SLL         4'b1111
-`define INST_ALU_OTHER       4'b0111
+`define INST_ALU_DOT8        4'b0001
 `define INST_ALU_BITS        4
 `define INST_ALU_CLASS(op)   op[3:2]
 `define INST_ALU_SIGNED(op)  op[0]
diff --git a/hw/rtl/core/VX_alu_dot8.sv b/hw/rtl/core/VX_alu_dot8.sv
new file mode 100644
index 0000000..87cec5b
--- /dev/null
+++ b/hw/rtl/core/VX_alu_dot8.sv
@@ -0,0 +1,115 @@
+// Copyright © 2019-2023
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+`include "VX_define.vh"
+
+module VX_alu_dot8 #(
+    parameter CORE_ID   = 0,
+    parameter NUM_LANES = 1
+) (
+    input wire          clk,
+    input wire          reset,
+
+    // Inputs
+    VX_execute_if.slave execute_if,
+
+    // Outputs
+    VX_commit_if.master commit_if
+);
+    `UNUSED_PARAM (CORE_ID)
+    localparam PID_BITS = `CLOG2(`NUM_THREADS / NUM_LANES);
+    localparam PID_WIDTH = `UP(PID_BITS);
+    //                     uuid,         wid,        tmask,      PC,     rd,        wb, pid,       sop, eop
+    localparam TAG_WIDTH = `UUID_WIDTH + `NW_WIDTH + NUM_LANES + `XLEN + `NR_BITS + 1 + PID_WIDTH + 1 + 1;
+    localparam LATENCY_DOT8 = 2;
+    localparam PE_RATIO = 2;
+    localparam NUM_PES = `UP(NUM_LANES / PE_RATIO);
+
+    `UNUSED_VAR (execute_if.data.op_type)
+    `UNUSED_VAR (execute_if.data.op_mod)
+    `UNUSED_VAR (execute_if.data.use_PC)
+    `UNUSED_VAR (execute_if.data.use_imm)
+    `UNUSED_VAR (execute_if.data.tid)
+    `UNUSED_VAR (execute_if.data.rs3_data)
+
+    wire [NUM_LANES-1:0][2*`XLEN-1:0] data_in;
+
+    for (genvar i = 0; i < NUM_LANES; ++i) begin
+        assign data_in[i][0 +: `XLEN] = execute_if.data.rs1_data[i];
+        assign data_in[i][`XLEN +: `XLEN] = execute_if.data.rs2_data[i];
+    end
+
+    wire pe_enable;
+    wire [NUM_PES-1:0][2*`XLEN-1:0] pe_data_in;
+    wire [NUM_PES-1:0][`XLEN-1:0] pe_data_out;
+
+    // PEs time-multiplexing
+    VX_pe_serializer #(
+        .NUM_LANES  (NUM_LANES),
+        .NUM_PES    (NUM_PES),
+        .LATENCY    (LATENCY_DOT8),
+        .DATA_IN_WIDTH (2*`XLEN),
+        .DATA_OUT_WIDTH (`XLEN),
+        .TAG_WIDTH  (TAG_WIDTH),
+        .PE_REG     (1)
+    ) pe_serializer (
+        .clk        (clk),
+        .reset      (reset),
+        .valid_in   (execute_if.valid),
+        .data_in    (data_in),
+        .tag_in     ({
+            execute_if.data.uuid,
+            execute_if.data.wid,
+            execute_if.data.tmask,
+            execute_if.data.PC,
+            execute_if.data.rd,
+            execute_if.data.wb,
+            execute_if.data.pid,
+            execute_if.data.sop,
+            execute_if.data.eop
+        }),
+        .ready_in   (execute_if.ready),
+        .pe_enable  (pe_enable),
+        .pe_data_in (pe_data_in),
+        .pe_data_out(pe_data_out),
+        .valid_out  (commit_if.valid),
+        .data_out   (commit_if.data.data),
+        .tag_out    ({
+            commit_if.data.uuid,
+            commit_if.data.wid,
+            commit_if.data.tmask,
+            commit_if.data.PC,
+            commit_if.data.rd,
+            commit_if.data.wb,
+            commit_if.data.pid,
+            commit_if.data.sop,
+            commit_if.data.eop
+        }),
+        .ready_out  (commit_if.ready)
+    );
+
+    // PEs instancing
+    for (genvar i = 0; i < NUM_PES; ++i) begin
+        wire [31:0] a = pe_data_in[i][0 +: 32];
+        wire [31:0] b = pe_data_in[i][32 +: 32];
+
+        // TODO:
+
+        wire [31:0] c = (a[7:0] * b[7:0]) + (a[15:8] * b[15:8]) + (a[23:16] * b[23:16]) + (a[31:24] * b[31:24]);
+
+        wire [31:0] result;
+        `BUFFER_EX(result, c, pe_enable, LATENCY_DOT8);
+        assign pe_data_out[i] = result;
+    end
+
+endmodule
diff --git a/hw/rtl/core/VX_alu_unit.sv b/hw/rtl/core/VX_alu_unit.sv
index 13a34f4..c92e05b 100644
--- a/hw/rtl/core/VX_alu_unit.sv
+++ b/hw/rtl/core/VX_alu_unit.sv
@@ -33,7 +33,7 @@ module VX_alu_unit #(
     localparam PID_BITS     = `CLOG2(`NUM_THREADS / NUM_LANES);
     localparam PID_WIDTH    = `UP(PID_BITS);
     localparam RSP_ARB_DATAW= `UUID_WIDTH + `NW_WIDTH + NUM_LANES + `XLEN + `NR_BITS + 1 + NUM_LANES * `XLEN + PID_WIDTH + 1 + 1;
-    localparam RSP_ARB_SIZE = 1 + `EXT_M_ENABLED;
+    localparam RSP_ARB_SIZE = 2 + `EXT_M_ENABLED;
     localparam PARTIAL_BW   = (BLOCK_SIZE != `ISSUE_WIDTH) || (NUM_LANES != `NUM_THREADS);
 
     VX_execute_if #(
@@ -60,6 +60,7 @@ module VX_alu_unit #(
         `RESET_RELAY (block_reset, reset);
 
         wire is_muldiv_op = `EXT_M_ENABLED && `INST_ALU_IS_M(per_block_execute_if[block_idx].data.op_mod);
+        wire is_dot8_op = (per_block_execute_if[block_idx].data.op_type == `INST_ALU_DOT8);
 
         VX_execute_if #(
             .NUM_LANES (NUM_LANES)
@@ -69,7 +70,7 @@ module VX_alu_unit #(
             .NUM_LANES (NUM_LANES)
         ) int_commit_if();
 
-        assign int_execute_if.valid = per_block_execute_if[block_idx].valid && ~is_muldiv_op;
+        assign int_execute_if.valid = per_block_execute_if[block_idx].valid && (~is_muldiv_op && ~is_dot8_op);
         assign int_execute_if.data = per_block_execute_if[block_idx].data;
 
         `RESET_RELAY (int_reset, block_reset);
@@ -86,6 +87,29 @@ module VX_alu_unit #(
             .commit_if  (int_commit_if)
         );
 
+        VX_execute_if #(
+            .NUM_LANES (NUM_LANES)
+        ) dot8_execute_if();
+
+        VX_commit_if #(
+            .NUM_LANES (NUM_LANES)
+        ) dot8_commit_if();
+
+        assign dot8_execute_if.valid = per_block_execute_if[block_idx].valid && (~is_muldiv_op && is_dot8_op);
+        assign dot8_execute_if.data = per_block_execute_if[block_idx].data;
+
+        `RESET_RELAY (dot8_reset, block_reset);
+
+         VX_alu_dot8 #(
+            .CORE_ID   (CORE_ID),
+            .NUM_LANES (NUM_LANES)
+         ) alu_dot8 (
+            .clk        (clk),
+            .reset      (dot8_reset),
+            .execute_if (dot8_execute_if),
+            .commit_if  (dot8_commit_if)
+        );
+
     `ifdef EXT_M_ENABLE
 
         VX_execute_if #(
@@ -101,6 +125,7 @@ module VX_alu_unit #(
 
         `RESET_RELAY (mdv_reset, block_reset);
 
+
         VX_alu_muldiv #(
             .CORE_ID   (CORE_ID),
             .NUM_LANES (NUM_LANES)
@@ -117,7 +142,7 @@ module VX_alu_unit #(
         `ifdef EXT_M_ENABLE
             is_muldiv_op ? mdv_execute_if.ready :
         `endif
-            int_execute_if.ready;
+            is_dot8_op ? dot8_execute_if.ready : int_execute_if.ready;
 
         // send response
 
@@ -132,18 +157,21 @@ module VX_alu_unit #(
             `ifdef EXT_M_ENABLE
                 mdv_commit_if.valid,
             `endif
+                dot8_commit_if.valid,
                 int_commit_if.valid
             }),
             .ready_in  ({
             `ifdef EXT_M_ENABLE
                 mdv_commit_if.ready,
             `endif
+                dot8_commit_if.ready,
                 int_commit_if.ready
             }),
             .data_in   ({
             `ifdef EXT_M_ENABLE
                 mdv_commit_if.data,
             `endif
+                dot8_commit_if.data,
                 int_commit_if.data
             }),
             .data_out  (per_block_commit_if[block_idx].data),
diff --git a/hw/rtl/core/VX_decode.sv b/hw/rtl/core/VX_decode.sv
index 33bba5c..1fa1a3c 100644
--- a/hw/rtl/core/VX_decode.sv
+++ b/hw/rtl/core/VX_decode.sv
@@ -486,6 +486,19 @@ module VX_decode  #(
                             default:;
                         endcase
                     end
+                    7'h01: begin
+                        case (func3)
+                            3'h0: begin // DOT8
+                                ex_type = `EX_ALU;
+                                op_type = `INST_OP_BITS'(`INST_ALU_DOT8);
+                                use_rd = 1;
+                                `USED_IREG (rd);
+                                `USED_IREG (rs1);
+                                `USED_IREG (rs2);
+                            end
+                            default:;
+                        endcase
+                    end
                     default:;
                 endcase
             end
diff --git a/hw/rtl/core/VX_trace.vh b/hw/rtl/core/VX_trace.vh
index 699b78f..2d8933e 100644
--- a/hw/rtl/core/VX_trace.vh
+++ b/hw/rtl/core/VX_trace.vh
@@ -125,6 +125,7 @@ task trace_ex_op(input int level,
                         `INST_ALU_XOR:   `TRACE(level, ("XOR"));
                         `INST_ALU_OR:    `TRACE(level, ("OR"));
                         `INST_ALU_AND:   `TRACE(level, ("AND"));
+                        `INST_ALU_DOT8:  `TRACE(level, ("DOT8"));
                         default:         `TRACE(level, ("?"));
                     endcase
                 end
diff --git a/kernel/include/vx_intrinsics.h b/kernel/include/vx_intrinsics.h
index c041d23..570cae8 100644
--- a/kernel/include/vx_intrinsics.h
+++ b/kernel/include/vx_intrinsics.h
@@ -233,6 +233,14 @@ inline void vx_fence() {
     asm volatile ("fence iorw, iorw");
 }
 
+// DOT8
+inline int vx_dot8(int a, int b) {
+    // TODO:
+    size_t ret; 
+    asm volatile (".insn r %1, 0, 1, %0, %2, %3" : "=r"(ret) : "i"(RISCV_CUSTOM0), "r"(a), "r"(b));
+    return ret; 
+}
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/sim/simx/decode.cpp b/sim/simx/decode.cpp
index 5f65716..6fdbcbf 100644
--- a/sim/simx/decode.cpp
+++ b/sim/simx/decode.cpp
@@ -1,674 +1,692 @@
-// Copyright © 2019-2023
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-// http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-#include <iostream>
-#include <string>
-#include <stdlib.h>
-#include <string.h>
-#include <iomanip>
-#include <vector>
-#include <unordered_map>
-#include <util.h>
-#include "debug.h"
-#include "types.h"
-#include "emulator.h"
-#include "arch.h"
-#include "instr.h"
-
-using namespace vortex;
-
-static const std::unordered_map<Opcode, InstType> sc_instTable = {
-  {Opcode::R,       InstType::R},
-  {Opcode::L,       InstType::I},
-  {Opcode::I,       InstType::I},
-  {Opcode::S,       InstType::S},
-  {Opcode::B,       InstType::B},
-  {Opcode::LUI,     InstType::U},
-  {Opcode::AUIPC,   InstType::U},
-  {Opcode::JAL,     InstType::J},
-  {Opcode::JALR,    InstType::I},
-  {Opcode::SYS,     InstType::I},
-  {Opcode::FENCE,   InstType::I},
-  {Opcode::AMO,     InstType::R},
-  {Opcode::FL,      InstType::I},
-  {Opcode::FS,      InstType::S},
-  {Opcode::FCI,     InstType::R},
-  {Opcode::FMADD,   InstType::R4},
-  {Opcode::FMSUB,   InstType::R4},
-  {Opcode::FMNMADD, InstType::R4},
-  {Opcode::FMNMSUB, InstType::R4},
-  {Opcode::EXT1,    InstType::R},
-  {Opcode::EXT2,    InstType::R4},
-  {Opcode::R_W,     InstType::R},
-  {Opcode::I_W,     InstType::I},
-};
-
-enum Constants {
-  width_opcode= 7,
-  width_reg   = 5,
-  width_func2 = 2,
-  width_func3 = 3,
-  width_func7 = 7,
-  width_i_imm = 12,
-  width_j_imm = 20,
-
-  shift_opcode= 0,
-  shift_rd    = width_opcode,
-  shift_func3 = shift_rd + width_reg,
-  shift_rs1   = shift_func3 + width_func3,
-  shift_rs2   = shift_rs1 + width_reg,
-  shift_func2 = shift_rs2 + width_reg,
-  shift_func7 = shift_rs2 + width_reg,
-  shift_rs3   = shift_func7 + width_func2,
-
-  mask_opcode = (1 << width_opcode) - 1,
-  mask_reg    = (1 << width_reg)   - 1,
-  mask_func2  = (1 << width_func2) - 1,
-  mask_func3  = (1 << width_func3) - 1,
-  mask_func7  = (1 << width_func7) - 1,
-  mask_i_imm  = (1 << width_i_imm) - 1,
-  mask_j_imm  = (1 << width_j_imm) - 1,
-};
-
-static const char* op_string(const Instr &instr) {
-  auto opcode = instr.getOpcode();
-  auto func2  = instr.getFunc2();
-  auto func3  = instr.getFunc3();
-  auto func7  = instr.getFunc7();
-  auto rd     = instr.getRDest();
-  auto rs2    = instr.getRSrc(1);
-  auto imm    = instr.getImm();
-
-  switch (opcode) {
-  case Opcode::LUI:   return "LUI";
-  case Opcode::AUIPC: return "AUIPC";
-  case Opcode::R:
-    if (func7 & 0x1) {
-      switch (func3) {
-      case 0: return "MUL";
-      case 1: return "MULH";
-      case 2: return "MULHSU";
-      case 3: return "MULHU";
-      case 4: return "DIV";
-      case 5: return "DIVU";
-      case 6: return "REM";
-      case 7: return "REMU";
-      default:
-        std::abort();
-      }
-    } else {
-      switch (func3) {
-      case 0: return (func7 & 0x20) ? "SUB" : "ADD";
-      case 1: return "SLL";
-      case 2: return "SLT";
-      case 3: return "SLTU";
-      case 4: return "XOR";
-      case 5: return (func7 & 0x20) ? "SRA" : "SRL";
-      case 6: return "OR";
-      case 7: return "AND";
-      default:
-        std::abort();
-      }
-    }
-  case Opcode::I:
-    switch (func3) {
-    case 0: return "ADDI";
-    case 1: return "SLLI";
-    case 2: return "SLTI";
-    case 3: return "SLTIU";
-    case 4: return "XORI";
-    case 5: return (func7 & 0x20) ? "SRAI" : "SRLI";
-    case 6: return "ORI";
-    case 7: return "ANDI";
-    default:
-      std::abort();
-    }
-  case Opcode::B:
-    switch (func3) {
-    case 0: return "BEQ";
-    case 1: return "BNE";
-    case 4: return "BLT";
-    case 5: return "BGE";
-    case 6: return "BLTU";
-    case 7: return "BGEU";
-    default:
-      std::abort();
-    }
-  case Opcode::JAL:   return "JAL";
-  case Opcode::JALR:  return "JALR";
-  case Opcode::L:
-    switch (func3) {
-    case 0: return "LB";
-    case 1: return "LH";
-    case 2: return "LW";
-    case 3: return "LD";
-    case 4: return "LBU";
-    case 5: return "LHU";
-    case 6: return "LWU";
-    default:
-      std::abort();
-    }
-  case Opcode::S:
-    switch (func3) {
-    case 0: return "SB";
-    case 1: return "SH";
-    case 2: return "SW";
-    case 3: return "SD";
-    default:
-      std::abort();
-    }
-  case Opcode::R_W:
-    if (func7 & 0x1){
-      switch (func3) {
-      case 0: return "MULW";
-      case 4: return "DIVW";
-      case 5: return "DIVUW";
-      case 6: return "REMW";
-      case 7: return "REMUW";
-      default:
-        std::abort();
-      }
-    } else {
-      switch (func3) {
-      case 0: return (func7 & 0x20) ? "SUBW" : "ADDW";
-      case 1: return "SLLW";
-      case 5: return (func7 & 0x20) ? "SRAW" : "SRLW";
-      default:
-        std::abort();
-      }
-    }
-  case Opcode::I_W:
-    switch (func3) {
-    case 0: return "ADDIW";
-    case 1: return "SLLIW";
-    case 5: return (func7 & 0x20) ? "SRAIW" : "SRLIW";
-    default:
-      std::abort();
-    }
-  case Opcode::SYS:
-    switch (func3) {
-    case 0:
-      switch (imm) {
-      case 0x000: return "ECALL";
-      case 0x001: return "EBREAK";
-      case 0x002: return "URET";
-      case 0x102: return "SRET";
-      case 0x302: return "MRET";
-      default:
-        std::abort();
-      }
-    case 1: return "CSRRW";
-    case 2: return "CSRRS";
-    case 3: return "CSRRC";
-    case 5: return "CSRRWI";
-    case 6: return "CSRRSI";
-    case 7: return "CSRRCI";
-    default:
-      std::abort();
-    }
-  case Opcode::FENCE: return "FENCE";
-  case Opcode::FL:
-    switch (func3) {
-    case 0x1: return "VL";
-    case 0x2: return "FLW";
-    case 0x3: return "FLD";
-    default:
-      std::abort();
-    }
-  case Opcode::FS:
-    switch (func3) {
-    case 0x1: return "VS";
-    case 0x2: return "FSW";
-    case 0x3: return "FSD";
-    default:
-      std::abort();
-    }
-  case Opcode::AMO: {
-    auto amo_type = func7 >> 2;
-    switch (func3) {
-      case 0x2:
-        switch (amo_type) {
-        case 0x00: return "AMOADD.W";
-        case 0x01: return "AMOSWAP.W";
-        case 0x02: return "LR.W";
-        case 0x03: return "SC.W";
-        case 0x04: return "AMOXOR.W";
-        case 0x08: return "AMOOR.W";
-        case 0x0c: return "AMOAND.W";
-        case 0x10: return "AMOMIN.W";
-        case 0x14: return "AMOMAX.W";
-        case 0x18: return "AMOMINU.W";
-        case 0x1c: return "AMOMAXU.W";
-        default:
-          std::abort();
-        }
-      case 0x3:
-        switch (amo_type) {
-        case 0x00: return "AMOADD.D";
-        case 0x01: return "AMOSWAP.D";
-        case 0x02: return "LR.D";
-        case 0x03: return "SC.D";
-        case 0x04: return "AMOXOR.D";
-        case 0x08: return "AMOOR.D";
-        case 0x0c: return "AMOAND.D";
-        case 0x10: return "AMOMIN.D";
-        case 0x14: return "AMOMAX.D";
-        case 0x18: return "AMOMINU.D";
-        case 0x1c: return "AMOMAXU.D";
-        default:
-          std::abort();
-        }
-      default:
-        std::abort();
-    }
-  }
-  case Opcode::FCI:
-    switch (func7) {
-    case 0x00: return "FADD.S";
-    case 0x01: return "FADD.D";
-    case 0x04: return "FSUB.S";
-    case 0x05: return "FSUB.D";
-    case 0x08: return "FMUL.S";
-    case 0x09: return "FMUL.D";
-    case 0x0c: return "FDIV.S";
-    case 0x0d: return "FDIV.D";
-    case 0x2c: return "FSQRT.S";
-    case 0x2d: return "FSQRT.D";
-    case 0x10:
-      switch (func3) {
-      case 0: return "FSGNJ.S";
-      case 1: return "FSGNJN.S";
-      case 2: return "FSGNJX.S";
-      default:
-        std::abort();
-      }
-    case 0x11:
-      switch (func3) {
-      case 0: return "FSGNJ.D";
-      case 1: return "FSGNJN.D";
-      case 2: return "FSGNJX.D";
-      default:
-        std::abort();
-      }
-    case 0x14:
-      switch (func3) {
-      case 0: return "FMIN.S";
-      case 1: return "FMAX.S";
-      default:
-        std::abort();
-      }
-    case 0x15:
-      switch (func3) {
-      case 0: return "FMIN.D";
-      case 1: return "FMAX.D";
-      default:
-        std::abort();
-      }
-    case 0x20: return "FCVT.S.D";
-    case 0x21: return "FCVT.D.S";
-    case 0x50:
-      switch (func3) {
-      case 0: return "FLE.S";
-      case 1: return "FLT.S";
-      case 2: return "FEQ.S";
-      default:
-        std::abort();
-      }
-    case 0x51:
-      switch (func3) {
-      case 0: return "FLE.D";
-      case 1: return "FLT.D";
-      case 2: return "FEQ.D";
-      default:
-        std::abort();
-      }
-    case 0x60:
-      switch (rs2) {
-      case 0: return "FCVT.W.S";
-      case 1: return "FCVT.WU.S";
-      case 2: return "FCVT.L.S";
-      case 3: return "FCVT.LU.S";
-      default:
-        std::abort();
-      }
-    case 0x61:
-      switch (rs2) {
-      case 0: return "FCVT.W.D";
-      case 1: return "FCVT.WU.D";
-      case 2: return "FCVT.L.D";
-      case 3: return "FCVT.LU.D";
-      default:
-        std::abort();
-      }
-    case 0x68:
-      switch (rs2) {
-      case 0: return "FCVT.S.W";
-      case 1: return "FCVT.S.WU";
-      case 2: return "FCVT.S.L";
-      case 3: return "FCVT.S.LU";
-      default:
-        std::abort();
-      }
-    case 0x69:
-      switch (rs2) {
-      case 0: return "FCVT.D.W";
-      case 1: return "FCVT.D.WU";
-      case 2: return "FCVT.D.L";
-      case 3: return "FCVT.D.LU";
-      default:
-        std::abort();
-      }
-    case 0x70: return func3 ? "FCLASS.S" : "FMV.X.S";
-    case 0x71: return func3 ? "FCLASS.D" : "FMV.X.D";
-    case 0x78: return "FMV.S.X";
-    case 0x79: return "FMV.D.X";
-    default:
-      std::abort();
-    }
-  case Opcode::FMADD:   return func2 ? "FMADD.D" : "FMADD.S";
-  case Opcode::FMSUB:   return func2 ? "FMSUB.D" : "FMSUB.S";
-  case Opcode::FMNMADD: return func2 ? "FNMADD.D" : "FNMADD.S";
-  case Opcode::FMNMSUB: return func2 ? "FNMSUB.D" : "FNMSUB.S";
-  case Opcode::EXT1:
-    switch (func7) {
-    case 0:
-      switch (func3) {
-      case 0: return "TMC";
-      case 1: return "WSPAWN";
-      case 2: return rs2 ? "SPLIT.N" : "SPLIT";
-      case 3: return "JOIN";
-      case 4: return "BAR";
-      case 5: return rd ? "PRED.N" : "PRED";
-      default:
-        std::abort();
-      }
-    default:
-      std::abort();
-    }
-  case Opcode::EXT2:
-    switch (func3) {
-    case 1: {
-      switch (func2) {
-      case 0: return "CMOV";
-      default:
-        std::abort();
-      }
-    }
-    default:
-      std::abort();
-    }
-  default:
-    std::abort();
-  }
-}
-
-namespace vortex {
-std::ostream &operator<<(std::ostream &os, const Instr &instr) {
-  os << op_string(instr);
-  int sep = 0;
-  if (instr.getRDType() != RegType::None) {
-    if (sep++ != 0) { os << ", "; } else { os << " "; }
-    os << instr.getRDType() << std::dec << instr.getRDest();
-  }
-  for (uint32_t i = 0; i < instr.getNRSrc(); ++i) {
-    if (sep++ != 0) { os << ", "; } else { os << " "; }
-    if (instr.getRSType(i) != RegType::None) {
-      os << instr.getRSType(i) << std::dec << instr.getRSrc(i);
-    } else {
-      os << "0x" << std::hex << instr.getRSrc(0);
-    }
-  }
-  if (instr.hasImm()) {
-    if (sep++ != 0) { os << ", "; } else { os << " "; }
-    os << "0x" << std::hex << instr.getImm();
-  }
-  return os;
-}
-}
-
-std::shared_ptr<Instr> Emulator::decode(uint32_t code) const {
-  auto instr = std::make_shared<Instr>();
-  auto op = Opcode((code >> shift_opcode) & mask_opcode);
-  instr->setOpcode(op);
-
-  auto func2 = (code >> shift_func2) & mask_func2;
-  auto func3 = (code >> shift_func3) & mask_func3;
-  auto func7 = (code >> shift_func7) & mask_func7;
-
-  auto rd  = (code >> shift_rd)  & mask_reg;
-  auto rs1 = (code >> shift_rs1) & mask_reg;
-  auto rs2 = (code >> shift_rs2) & mask_reg;
-  auto rs3 = (code >> shift_rs3) & mask_reg;
-
-  auto op_it = sc_instTable.find(op);
-  if (op_it == sc_instTable.end()) {
-    std::cout << std::hex << "Error: invalid opcode: 0x" << static_cast<int>(op) << std::endl;
-    return nullptr;
-  }
-
-  auto iType = op_it->second;
-  switch (iType) {
-  case InstType::R:
-    switch (op) {
-    case Opcode::FCI:
-      switch (func7) {
-      case 0x2c: // FSQRT.S
-      case 0x2d: // FSQRT.D
-        instr->setDestReg(rd, RegType::Float);
-        instr->addSrcReg(rs1, RegType::Float);
-        break;
-      case 0x50: // FLE.S, FLT.S, FEQ.S
-      case 0x51: // FLE.D, FLT.D, FEQ.D
-        instr->setDestReg(rd, RegType::Integer);
-        instr->addSrcReg(rs1, RegType::Float);
-        instr->addSrcReg(rs2, RegType::Float);
-        break;
-      case 0x60: // FCVT.W.D, FCVT.WU.D, FCVT.L.D, FCVT.LU.D
-      case 0x61: // FCVT.WU.S, FCVT.W.S, FCVT.L.S, FCVT.LU.S
-        instr->setDestReg(rd, RegType::Integer);
-        instr->addSrcReg(rs1, RegType::Float);
-        instr->addSrcReg(rs2, RegType::None);
-        break;
-      case 0x68: // FCVT.S.W, FCVT.S.WU, FCVT.S.L, FCVT.S.LU
-      case 0x69: // FCVT.D.W, FCVT.D.WU, FCVT.D.L, FCVT.D.LU
-        instr->setDestReg(rd, RegType::Float);
-        instr->addSrcReg(rs1, RegType::Integer);
-        instr->addSrcReg(rs2, RegType::None);
-        break;
-      case 0x70: // FCLASS.S, FMV.X.S
-      case 0x71: // FCLASS.D, FMV.X.D
-        instr->setDestReg(rd, RegType::Integer);
-        instr->addSrcReg(rs1, RegType::Float);
-        break;
-      case 0x78: // FMV.S.X
-      case 0x79: // FMV.D.X
-        instr->setDestReg(rd, RegType::Float);
-        instr->addSrcReg(rs1, RegType::Integer);
-        break;
-      default:
-        instr->setDestReg(rd, RegType::Float);
-        instr->addSrcReg(rs1, RegType::Float);
-        instr->addSrcReg(rs2, RegType::Float);
-        break;
-      }
-      break;
-    case Opcode::EXT1:
-      switch (func7) {
-      case 0:
-        switch (func3) {
-        case 0: // TMC
-        case 3: // JOIN
-          instr->addSrcReg(rs1, RegType::Integer);
-          break;
-        case 1: // WSPAWN
-        case 4: // BAR
-          instr->addSrcReg(rs1, RegType::Integer);
-          instr->addSrcReg(rs2, RegType::Integer);
-          break;
-        case 5: // PRED
-          instr->setDestReg(rd, RegType::None);
-          instr->addSrcReg(rs1, RegType::Integer);
-          instr->addSrcReg(rs2, RegType::Integer);
-          break;
-        case 2: // SPLIT
-          instr->setDestReg(rd, RegType::Integer);
-          instr->addSrcReg(rs1, RegType::Integer);
-          instr->addSrcReg(rs2, RegType::None);
-          break;
-        default:
-          std::abort();
-        }
-        break;
-      default:
-        std::abort();
-      }
-      break;
-    default:
-      instr->setDestReg(rd, RegType::Integer);
-      instr->addSrcReg(rs1, RegType::Integer);
-      instr->addSrcReg(rs2, RegType::Integer);
-      break;
-    }
-    instr->setFunc3(func3);
-    instr->setFunc7(func7);
-    break;
-
-  case InstType::I: {
-    switch (op) {
-    case Opcode::I:
-    case Opcode::I_W:
-    case Opcode::JALR:
-      instr->setDestReg(rd, RegType::Integer);
-      instr->addSrcReg(rs1, RegType::Integer);
-      instr->setFunc3(func3);
-      if (func3 == 0x1 || func3 == 0x5) {
-        // Shift instructions
-        auto shamt = rs2; // uint5
-      #if (XLEN == 64)
-        if (op == Opcode::I) {
-          // uint6
-          shamt |= ((func7 & 0x1) << 5);
-        }
-      #endif
-        instr->setImm(shamt);
-        instr->setFunc7(func7);
-      } else {
-        auto imm = code >> shift_rs2;
-        instr->setImm(sext(imm, width_i_imm));
-      }
-      break;
-    case Opcode::L:
-    case Opcode::FL: {
-      instr->setDestReg(rd, (op == Opcode::FL) ? RegType::Float : RegType::Integer);
-      instr->addSrcReg(rs1, RegType::Integer);
-      instr->setFunc3(func3);
-      auto imm = code >> shift_rs2;
-      instr->setImm(sext(imm, width_i_imm));
-    } break;
-    case Opcode::FENCE:
-      instr->setFunc3(func3);
-      instr->setImm(code >> shift_rs2);
-      break;
-    case Opcode::SYS:
-      if (func3 != 0) {
-        // CSR instructions
-        instr->setDestReg(rd, RegType::Integer);
-        instr->setFunc3(func3);
-        if (func3 < 5) {
-          instr->addSrcReg(rs1, RegType::Integer);
-        } else {
-          // zimm
-          instr->addSrcReg(rs1, RegType::None);
-        }
-        instr->setImm(code >> shift_rs2);
-      } else {
-        // ECALL/EBREACK instructions
-        instr->setImm(code >> shift_rs2);
-      }
-      break;
-    default:
-      std::abort();
-      break;
-    }
-  } break;
-  case InstType::S: {
-    instr->addSrcReg(rs1, RegType::Integer);
-    instr->addSrcReg(rs2, (op == Opcode::FS) ? RegType::Float : RegType::Integer);
-    instr->setFunc3(func3);
-    auto imm = (func7 << width_reg) | rd;
-    instr->setImm(sext(imm, width_i_imm));
-  } break;
-
-  case InstType::B: {
-    instr->addSrcReg(rs1, RegType::Integer);
-    instr->addSrcReg(rs2, RegType::Integer);
-    instr->setFunc3(func3);
-    auto bit_11   = rd & 0x1;
-    auto bits_4_1 = rd >> 1;
-    auto bit_10_5 = func7 & 0x3f;
-    auto bit_12   = func7 >> 6;
-    auto imm = (bits_4_1 << 1) | (bit_10_5 << 5) | (bit_11 << 11) | (bit_12 << 12);
-    instr->setImm(sext(imm, width_i_imm+1));
-  } break;
-
-  case InstType::U: {
-    instr->setDestReg(rd, RegType::Integer);
-    auto imm = (code >> shift_func3) << shift_func3;
-    instr->setImm(imm);
-  }  break;
-
-  case InstType::J: {
-    instr->setDestReg(rd, RegType::Integer);
-    auto unordered  = code >> shift_func3;
-    auto bits_19_12 = unordered & 0xff;
-    auto bit_11     = (unordered >> 8) & 0x1;
-    auto bits_10_1  = (unordered >> 9) & 0x3ff;
-    auto bit_20     = (unordered >> 19) & 0x1;
-    auto imm = (bits_10_1 << 1) | (bit_11 << 11) | (bits_19_12 << 12) | (bit_20 << 20);
-    instr->setImm(sext(imm, width_j_imm+1));
-  } break;
-
-  case InstType::R4:
-    if (op == Opcode::EXT2) {
-      switch (func3) {
-      case 1:
-        switch (func2) {
-        case 0: // CMOV
-          instr->setDestReg(rd, RegType::Integer);
-          instr->addSrcReg(rs1, RegType::Integer);
-          instr->addSrcReg(rs2, RegType::Integer);
-          instr->addSrcReg(rs3, RegType::Integer);
-          break;
-        default:
-          std::abort();
-        }
-        break;
-      default:
-        std::abort();
-      }
-    } else {
-      instr->setDestReg(rd, RegType::Float);
-      instr->addSrcReg(rs1, RegType::Float);
-      instr->addSrcReg(rs2, RegType::Float);
-      instr->addSrcReg(rs3, RegType::Float);
-    }
-    instr->setFunc2(func2);
-    instr->setFunc3(func3);
-    break;
-
-  default:
-    std::abort();
-  }
-
-  return instr;
-}
+// Copyright © 2019-2023
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#include <iostream>
+#include <string>
+#include <stdlib.h>
+#include <string.h>
+#include <iomanip>
+#include <vector>
+#include <unordered_map>
+#include <util.h>
+#include "debug.h"
+#include "types.h"
+#include "emulator.h"
+#include "arch.h"
+#include "instr.h"
+
+using namespace vortex;
+
+static const std::unordered_map<Opcode, InstType> sc_instTable = {
+  {Opcode::R,       InstType::R},
+  {Opcode::L,       InstType::I},
+  {Opcode::I,       InstType::I},
+  {Opcode::S,       InstType::S},
+  {Opcode::B,       InstType::B},
+  {Opcode::LUI,     InstType::U},
+  {Opcode::AUIPC,   InstType::U},
+  {Opcode::JAL,     InstType::J},
+  {Opcode::JALR,    InstType::I},
+  {Opcode::SYS,     InstType::I},
+  {Opcode::FENCE,   InstType::I},
+  {Opcode::AMO,     InstType::R},
+  {Opcode::FL,      InstType::I},
+  {Opcode::FS,      InstType::S},
+  {Opcode::FCI,     InstType::R},
+  {Opcode::FMADD,   InstType::R4},
+  {Opcode::FMSUB,   InstType::R4},
+  {Opcode::FMNMADD, InstType::R4},
+  {Opcode::FMNMSUB, InstType::R4},
+  {Opcode::EXT1,    InstType::R},
+  {Opcode::EXT2,    InstType::R4},
+  {Opcode::R_W,     InstType::R},
+  {Opcode::I_W,     InstType::I},
+};
+
+enum Constants {
+  width_opcode= 7,
+  width_reg   = 5,
+  width_func2 = 2,
+  width_func3 = 3,
+  width_func7 = 7,
+  width_i_imm = 12,
+  width_j_imm = 20,
+
+  shift_opcode= 0,
+  shift_rd    = width_opcode,
+  shift_func3 = shift_rd + width_reg,
+  shift_rs1   = shift_func3 + width_func3,
+  shift_rs2   = shift_rs1 + width_reg,
+  shift_func2 = shift_rs2 + width_reg,
+  shift_func7 = shift_rs2 + width_reg,
+  shift_rs3   = shift_func7 + width_func2,
+
+  mask_opcode = (1 << width_opcode) - 1,
+  mask_reg    = (1 << width_reg)   - 1,
+  mask_func2  = (1 << width_func2) - 1,
+  mask_func3  = (1 << width_func3) - 1,
+  mask_func7  = (1 << width_func7) - 1,
+  mask_i_imm  = (1 << width_i_imm) - 1,
+  mask_j_imm  = (1 << width_j_imm) - 1,
+};
+
+static const char* op_string(const Instr &instr) {
+  auto opcode = instr.getOpcode();
+  auto func2  = instr.getFunc2();
+  auto func3  = instr.getFunc3();
+  auto func7  = instr.getFunc7();
+  auto rd     = instr.getRDest();
+  auto rs2    = instr.getRSrc(1);
+  auto imm    = instr.getImm();
+
+  switch (opcode) {
+  case Opcode::LUI:   return "LUI";
+  case Opcode::AUIPC: return "AUIPC";
+  case Opcode::R:
+    if (func7 & 0x1) {
+      switch (func3) {
+      case 0: return "MUL";
+      case 1: return "MULH";
+      case 2: return "MULHSU";
+      case 3: return "MULHU";
+      case 4: return "DIV";
+      case 5: return "DIVU";
+      case 6: return "REM";
+      case 7: return "REMU";
+      default:
+        std::abort();
+      }
+    } else {
+      switch (func3) {
+      case 0: return (func7 & 0x20) ? "SUB" : "ADD";
+      case 1: return "SLL";
+      case 2: return "SLT";
+      case 3: return "SLTU";
+      case 4: return "XOR";
+      case 5: return (func7 & 0x20) ? "SRA" : "SRL";
+      case 6: return "OR";
+      case 7: return "AND";
+      default:
+        std::abort();
+      }
+    }
+  case Opcode::I:
+    switch (func3) {
+    case 0: return "ADDI";
+    case 1: return "SLLI";
+    case 2: return "SLTI";
+    case 3: return "SLTIU";
+    case 4: return "XORI";
+    case 5: return (func7 & 0x20) ? "SRAI" : "SRLI";
+    case 6: return "ORI";
+    case 7: return "ANDI";
+    default:
+      std::abort();
+    }
+  case Opcode::B:
+    switch (func3) {
+    case 0: return "BEQ";
+    case 1: return "BNE";
+    case 4: return "BLT";
+    case 5: return "BGE";
+    case 6: return "BLTU";
+    case 7: return "BGEU";
+    default:
+      std::abort();
+    }
+  case Opcode::JAL:   return "JAL";
+  case Opcode::JALR:  return "JALR";
+  case Opcode::L:
+    switch (func3) {
+    case 0: return "LB";
+    case 1: return "LH";
+    case 2: return "LW";
+    case 3: return "LD";
+    case 4: return "LBU";
+    case 5: return "LHU";
+    case 6: return "LWU";
+    default:
+      std::abort();
+    }
+  case Opcode::S:
+    switch (func3) {
+    case 0: return "SB";
+    case 1: return "SH";
+    case 2: return "SW";
+    case 3: return "SD";
+    default:
+      std::abort();
+    }
+  case Opcode::R_W:
+    if (func7 & 0x1){
+      switch (func3) {
+      case 0: return "MULW";
+      case 4: return "DIVW";
+      case 5: return "DIVUW";
+      case 6: return "REMW";
+      case 7: return "REMUW";
+      default:
+        std::abort();
+      }
+    } else {
+      switch (func3) {
+      case 0: return (func7 & 0x20) ? "SUBW" : "ADDW";
+      case 1: return "SLLW";
+      case 5: return (func7 & 0x20) ? "SRAW" : "SRLW";
+      default:
+        std::abort();
+      }
+    }
+  case Opcode::I_W:
+    switch (func3) {
+    case 0: return "ADDIW";
+    case 1: return "SLLIW";
+    case 5: return (func7 & 0x20) ? "SRAIW" : "SRLIW";
+    default:
+      std::abort();
+    }
+  case Opcode::SYS:
+    switch (func3) {
+    case 0:
+      switch (imm) {
+      case 0x000: return "ECALL";
+      case 0x001: return "EBREAK";
+      case 0x002: return "URET";
+      case 0x102: return "SRET";
+      case 0x302: return "MRET";
+      default:
+        std::abort();
+      }
+    case 1: return "CSRRW";
+    case 2: return "CSRRS";
+    case 3: return "CSRRC";
+    case 5: return "CSRRWI";
+    case 6: return "CSRRSI";
+    case 7: return "CSRRCI";
+    default:
+      std::abort();
+    }
+  case Opcode::FENCE: return "FENCE";
+  case Opcode::FL:
+    switch (func3) {
+    case 0x1: return "VL";
+    case 0x2: return "FLW";
+    case 0x3: return "FLD";
+    default:
+      std::abort();
+    }
+  case Opcode::FS:
+    switch (func3) {
+    case 0x1: return "VS";
+    case 0x2: return "FSW";
+    case 0x3: return "FSD";
+    default:
+      std::abort();
+    }
+  case Opcode::AMO: {
+    auto amo_type = func7 >> 2;
+    switch (func3) {
+      case 0x2:
+        switch (amo_type) {
+        case 0x00: return "AMOADD.W";
+        case 0x01: return "AMOSWAP.W";
+        case 0x02: return "LR.W";
+        case 0x03: return "SC.W";
+        case 0x04: return "AMOXOR.W";
+        case 0x08: return "AMOOR.W";
+        case 0x0c: return "AMOAND.W";
+        case 0x10: return "AMOMIN.W";
+        case 0x14: return "AMOMAX.W";
+        case 0x18: return "AMOMINU.W";
+        case 0x1c: return "AMOMAXU.W";
+        default:
+          std::abort();
+        }
+      case 0x3:
+        switch (amo_type) {
+        case 0x00: return "AMOADD.D";
+        case 0x01: return "AMOSWAP.D";
+        case 0x02: return "LR.D";
+        case 0x03: return "SC.D";
+        case 0x04: return "AMOXOR.D";
+        case 0x08: return "AMOOR.D";
+        case 0x0c: return "AMOAND.D";
+        case 0x10: return "AMOMIN.D";
+        case 0x14: return "AMOMAX.D";
+        case 0x18: return "AMOMINU.D";
+        case 0x1c: return "AMOMAXU.D";
+        default:
+          std::abort();
+        }
+      default:
+        std::abort();
+    }
+  }
+  case Opcode::FCI:
+    switch (func7) {
+    case 0x00: return "FADD.S";
+    case 0x01: return "FADD.D";
+    case 0x04: return "FSUB.S";
+    case 0x05: return "FSUB.D";
+    case 0x08: return "FMUL.S";
+    case 0x09: return "FMUL.D";
+    case 0x0c: return "FDIV.S";
+    case 0x0d: return "FDIV.D";
+    case 0x2c: return "FSQRT.S";
+    case 0x2d: return "FSQRT.D";
+    case 0x10:
+      switch (func3) {
+      case 0: return "FSGNJ.S";
+      case 1: return "FSGNJN.S";
+      case 2: return "FSGNJX.S";
+      default:
+        std::abort();
+      }
+    case 0x11:
+      switch (func3) {
+      case 0: return "FSGNJ.D";
+      case 1: return "FSGNJN.D";
+      case 2: return "FSGNJX.D";
+      default:
+        std::abort();
+      }
+    case 0x14:
+      switch (func3) {
+      case 0: return "FMIN.S";
+      case 1: return "FMAX.S";
+      default:
+        std::abort();
+      }
+    case 0x15:
+      switch (func3) {
+      case 0: return "FMIN.D";
+      case 1: return "FMAX.D";
+      default:
+        std::abort();
+      }
+    case 0x20: return "FCVT.S.D";
+    case 0x21: return "FCVT.D.S";
+    case 0x50:
+      switch (func3) {
+      case 0: return "FLE.S";
+      case 1: return "FLT.S";
+      case 2: return "FEQ.S";
+      default:
+        std::abort();
+      }
+    case 0x51:
+      switch (func3) {
+      case 0: return "FLE.D";
+      case 1: return "FLT.D";
+      case 2: return "FEQ.D";
+      default:
+        std::abort();
+      }
+    case 0x60:
+      switch (rs2) {
+      case 0: return "FCVT.W.S";
+      case 1: return "FCVT.WU.S";
+      case 2: return "FCVT.L.S";
+      case 3: return "FCVT.LU.S";
+      default:
+        std::abort();
+      }
+    case 0x61:
+      switch (rs2) {
+      case 0: return "FCVT.W.D";
+      case 1: return "FCVT.WU.D";
+      case 2: return "FCVT.L.D";
+      case 3: return "FCVT.LU.D";
+      default:
+        std::abort();
+      }
+    case 0x68:
+      switch (rs2) {
+      case 0: return "FCVT.S.W";
+      case 1: return "FCVT.S.WU";
+      case 2: return "FCVT.S.L";
+      case 3: return "FCVT.S.LU";
+      default:
+        std::abort();
+      }
+    case 0x69:
+      switch (rs2) {
+      case 0: return "FCVT.D.W";
+      case 1: return "FCVT.D.WU";
+      case 2: return "FCVT.D.L";
+      case 3: return "FCVT.D.LU";
+      default:
+        std::abort();
+      }
+    case 0x70: return func3 ? "FCLASS.S" : "FMV.X.S";
+    case 0x71: return func3 ? "FCLASS.D" : "FMV.X.D";
+    case 0x78: return "FMV.S.X";
+    case 0x79: return "FMV.D.X";
+    default:
+      std::abort();
+    }
+  case Opcode::FMADD:   return func2 ? "FMADD.D" : "FMADD.S";
+  case Opcode::FMSUB:   return func2 ? "FMSUB.D" : "FMSUB.S";
+  case Opcode::FMNMADD: return func2 ? "FNMADD.D" : "FNMADD.S";
+  case Opcode::FMNMSUB: return func2 ? "FNMSUB.D" : "FNMSUB.S";
+  case Opcode::EXT1:
+    switch (func7) {
+    case 0:
+      switch (func3) {
+      case 0: return "TMC";
+      case 1: return "WSPAWN";
+      case 2: return rs2 ? "SPLIT.N" : "SPLIT";
+      case 3: return "JOIN";
+      case 4: return "BAR";
+      case 5: return rd ? "PRED.N" : "PRED";
+      default:
+        std::abort();
+      }
+    case 1:
+      switch (func3) {
+      case 0: return "DOT8";
+      default:
+        std::abort();
+      }
+    default:
+      std::abort();
+    }
+  case Opcode::EXT2:
+    switch (func3) {
+    case 1: {
+      switch (func2) {
+      case 0: return "CMOV";
+      default:
+        std::abort();
+      }
+    }
+    default:
+      std::abort();
+    }
+  default:
+    std::abort();
+  }
+}
+
+namespace vortex {
+std::ostream &operator<<(std::ostream &os, const Instr &instr) {
+  os << op_string(instr);
+  int sep = 0;
+  if (instr.getRDType() != RegType::None) {
+    if (sep++ != 0) { os << ", "; } else { os << " "; }
+    os << instr.getRDType() << std::dec << instr.getRDest();
+  }
+  for (uint32_t i = 0; i < instr.getNRSrc(); ++i) {
+    if (sep++ != 0) { os << ", "; } else { os << " "; }
+    if (instr.getRSType(i) != RegType::None) {
+      os << instr.getRSType(i) << std::dec << instr.getRSrc(i);
+    } else {
+      os << "0x" << std::hex << instr.getRSrc(0);
+    }
+  }
+  if (instr.hasImm()) {
+    if (sep++ != 0) { os << ", "; } else { os << " "; }
+    os << "0x" << std::hex << instr.getImm();
+  }
+  return os;
+}
+}
+
+std::shared_ptr<Instr> Emulator::decode(uint32_t code) const {
+  auto instr = std::make_shared<Instr>();
+  auto op = Opcode((code >> shift_opcode) & mask_opcode);
+  instr->setOpcode(op);
+
+  auto func2 = (code >> shift_func2) & mask_func2;
+  auto func3 = (code >> shift_func3) & mask_func3;
+  auto func7 = (code >> shift_func7) & mask_func7;
+
+  auto rd  = (code >> shift_rd)  & mask_reg;
+  auto rs1 = (code >> shift_rs1) & mask_reg;
+  auto rs2 = (code >> shift_rs2) & mask_reg;
+  auto rs3 = (code >> shift_rs3) & mask_reg;
+
+  auto op_it = sc_instTable.find(op);
+  if (op_it == sc_instTable.end()) {
+    std::cout << std::hex << "Error: invalid opcode: 0x" << static_cast<int>(op) << std::endl;
+    return nullptr;
+  }
+
+  auto iType = op_it->second;
+  switch (iType) {
+  case InstType::R:
+    switch (op) {
+    case Opcode::FCI:
+      switch (func7) {
+      case 0x2c: // FSQRT.S
+      case 0x2d: // FSQRT.D
+        instr->setDestReg(rd, RegType::Float);
+        instr->addSrcReg(rs1, RegType::Float);
+        break;
+      case 0x50: // FLE.S, FLT.S, FEQ.S
+      case 0x51: // FLE.D, FLT.D, FEQ.D
+        instr->setDestReg(rd, RegType::Integer);
+        instr->addSrcReg(rs1, RegType::Float);
+        instr->addSrcReg(rs2, RegType::Float);
+        break;
+      case 0x60: // FCVT.W.D, FCVT.WU.D, FCVT.L.D, FCVT.LU.D
+      case 0x61: // FCVT.WU.S, FCVT.W.S, FCVT.L.S, FCVT.LU.S
+        instr->setDestReg(rd, RegType::Integer);
+        instr->addSrcReg(rs1, RegType::Float);
+        instr->addSrcReg(rs2, RegType::None);
+        break;
+      case 0x68: // FCVT.S.W, FCVT.S.WU, FCVT.S.L, FCVT.S.LU
+      case 0x69: // FCVT.D.W, FCVT.D.WU, FCVT.D.L, FCVT.D.LU
+        instr->setDestReg(rd, RegType::Float);
+        instr->addSrcReg(rs1, RegType::Integer);
+        instr->addSrcReg(rs2, RegType::None);
+        break;
+      case 0x70: // FCLASS.S, FMV.X.S
+      case 0x71: // FCLASS.D, FMV.X.D
+        instr->setDestReg(rd, RegType::Integer);
+        instr->addSrcReg(rs1, RegType::Float);
+        break;
+      case 0x78: // FMV.S.X
+      case 0x79: // FMV.D.X
+        instr->setDestReg(rd, RegType::Float);
+        instr->addSrcReg(rs1, RegType::Integer);
+        break;
+      default:
+        instr->setDestReg(rd, RegType::Float);
+        instr->addSrcReg(rs1, RegType::Float);
+        instr->addSrcReg(rs2, RegType::Float);
+        break;
+      }
+      break;
+    case Opcode::EXT1:
+      switch (func7) {
+      case 0:
+        switch (func3) {
+        case 0: // TMC
+        case 3: // JOIN
+          instr->addSrcReg(rs1, RegType::Integer);
+          break;
+        case 1: // WSPAWN
+        case 4: // BAR
+          instr->addSrcReg(rs1, RegType::Integer);
+          instr->addSrcReg(rs2, RegType::Integer);
+          break;
+        case 5: // PRED
+          instr->setDestReg(rd, RegType::None);
+          instr->addSrcReg(rs1, RegType::Integer);
+          instr->addSrcReg(rs2, RegType::Integer);
+          break;
+        case 2: // SPLIT
+          instr->setDestReg(rd, RegType::Integer);
+          instr->addSrcReg(rs1, RegType::Integer);
+          instr->addSrcReg(rs2, RegType::None);
+          break;
+        default:
+          std::abort();
+        }
+        break;
+      case 1:
+        switch (func3) {
+        case 0: // DOT8
+          // TODO:
+          instr->setDestReg(rd, RegType::Integer);
+          instr->addSrcReg(rs1, RegType::Integer);
+          instr->addSrcReg(rs2, RegType::Integer);
+          break;
+        default:
+          std::abort();
+        }
+        break;
+      default:
+        std::abort();
+      }
+      break;
+    default:
+      instr->setDestReg(rd, RegType::Integer);
+      instr->addSrcReg(rs1, RegType::Integer);
+      instr->addSrcReg(rs2, RegType::Integer);
+      break;
+    }
+    instr->setFunc3(func3);
+    instr->setFunc7(func7);
+    break;
+
+  case InstType::I: {
+    switch (op) {
+    case Opcode::I:
+    case Opcode::I_W:
+    case Opcode::JALR:
+      instr->setDestReg(rd, RegType::Integer);
+      instr->addSrcReg(rs1, RegType::Integer);
+      instr->setFunc3(func3);
+      if (func3 == 0x1 || func3 == 0x5) {
+        // Shift instructions
+        auto shamt = rs2; // uint5
+      #if (XLEN == 64)
+        if (op == Opcode::I) {
+          // uint6
+          shamt |= ((func7 & 0x1) << 5);
+        }
+      #endif
+        instr->setImm(shamt);
+        instr->setFunc7(func7);
+      } else {
+        auto imm = code >> shift_rs2;
+        instr->setImm(sext(imm, width_i_imm));
+      }
+      break;
+    case Opcode::L:
+    case Opcode::FL: {
+      instr->setDestReg(rd, (op == Opcode::FL) ? RegType::Float : RegType::Integer);
+      instr->addSrcReg(rs1, RegType::Integer);
+      instr->setFunc3(func3);
+      auto imm = code >> shift_rs2;
+      instr->setImm(sext(imm, width_i_imm));
+    } break;
+    case Opcode::FENCE:
+      instr->setFunc3(func3);
+      instr->setImm(code >> shift_rs2);
+      break;
+    case Opcode::SYS:
+      if (func3 != 0) {
+        // CSR instructions
+        instr->setDestReg(rd, RegType::Integer);
+        instr->setFunc3(func3);
+        if (func3 < 5) {
+          instr->addSrcReg(rs1, RegType::Integer);
+        } else {
+          // zimm
+          instr->addSrcReg(rs1, RegType::None);
+        }
+        instr->setImm(code >> shift_rs2);
+      } else {
+        // ECALL/EBREACK instructions
+        instr->setImm(code >> shift_rs2);
+      }
+      break;
+    default:
+      std::abort();
+      break;
+    }
+  } break;
+  case InstType::S: {
+    instr->addSrcReg(rs1, RegType::Integer);
+    instr->addSrcReg(rs2, (op == Opcode::FS) ? RegType::Float : RegType::Integer);
+    instr->setFunc3(func3);
+    auto imm = (func7 << width_reg) | rd;
+    instr->setImm(sext(imm, width_i_imm));
+  } break;
+
+  case InstType::B: {
+    instr->addSrcReg(rs1, RegType::Integer);
+    instr->addSrcReg(rs2, RegType::Integer);
+    instr->setFunc3(func3);
+    auto bit_11   = rd & 0x1;
+    auto bits_4_1 = rd >> 1;
+    auto bit_10_5 = func7 & 0x3f;
+    auto bit_12   = func7 >> 6;
+    auto imm = (bits_4_1 << 1) | (bit_10_5 << 5) | (bit_11 << 11) | (bit_12 << 12);
+    instr->setImm(sext(imm, width_i_imm+1));
+  } break;
+
+  case InstType::U: {
+    instr->setDestReg(rd, RegType::Integer);
+    auto imm = (code >> shift_func3) << shift_func3;
+    instr->setImm(imm);
+  }  break;
+
+  case InstType::J: {
+    instr->setDestReg(rd, RegType::Integer);
+    auto unordered  = code >> shift_func3;
+    auto bits_19_12 = unordered & 0xff;
+    auto bit_11     = (unordered >> 8) & 0x1;
+    auto bits_10_1  = (unordered >> 9) & 0x3ff;
+    auto bit_20     = (unordered >> 19) & 0x1;
+    auto imm = (bits_10_1 << 1) | (bit_11 << 11) | (bits_19_12 << 12) | (bit_20 << 20);
+    instr->setImm(sext(imm, width_j_imm+1));
+  } break;
+
+  case InstType::R4:
+    if (op == Opcode::EXT2) {
+      switch (func3) {
+      case 1:
+        switch (func2) {
+        case 0: // CMOV
+          instr->setDestReg(rd, RegType::Integer);
+          instr->addSrcReg(rs1, RegType::Integer);
+          instr->addSrcReg(rs2, RegType::Integer);
+          instr->addSrcReg(rs3, RegType::Integer);
+          break;
+        default:
+          std::abort();
+        }
+        break;
+      default:
+        std::abort();
+      }
+    } else {
+      instr->setDestReg(rd, RegType::Float);
+      instr->addSrcReg(rs1, RegType::Float);
+      instr->addSrcReg(rs2, RegType::Float);
+      instr->addSrcReg(rs3, RegType::Float);
+    }
+    instr->setFunc2(func2);
+    instr->setFunc3(func3);
+    break;
+
+  default:
+    std::abort();
+  }
+
+  return instr;
+}
diff --git a/sim/simx/execute.cpp b/sim/simx/execute.cpp
index 56f2d2c..526368f 100644
--- a/sim/simx/execute.cpp
+++ b/sim/simx/execute.cpp
@@ -1,1492 +1,1528 @@
-// Copyright © 2019-2023
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-// http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-#include <iostream>
-#include <stdlib.h>
-#include <unistd.h>
-#include <math.h>
-#include <bitset>
-#include <climits>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <assert.h>
-#include <util.h>
-#include <rvfloats.h>
-#include "emulator.h"
-#include "instr.h"
-#include "core.h"
-
-using namespace vortex;
-
-union reg_data_t {
-  Word     u;
-  WordI    i;
-  WordF    f;
-  float    f32;
-  double   f64;
-  uint32_t u32;
-  uint64_t u64;
-  int32_t  i32;
-  int64_t  i64;
-};
-
-inline uint64_t nan_box(uint32_t value) {
-  uint64_t mask = 0xffffffff00000000;
-  return value | mask;
-}
-
-inline bool is_nan_boxed(uint64_t value) {
-  return (uint32_t(value >> 32) == 0xffffffff);
-}
-
-inline int64_t check_boxing(int64_t a) {
-  if (is_nan_boxed(a))
-    return a;
-  return nan_box(0x7fc00000); // NaN
-}
-
-void Emulator::execute(const Instr &instr, uint32_t wid, instr_trace_t *trace) {
-  auto& warp = warps_.at(wid);
-  assert(warp.tmask.any());
-
-  // initialize instruction trace
-  trace->cid   = core_->id();
-  trace->wid   = wid;
-  trace->PC    = warp.PC;
-  trace->tmask = warp.tmask;
-  trace->rdest = instr.getRDest();
-  trace->rdest_type = instr.getRDType();
-
-  auto next_pc = warp.PC + 4;
-  auto next_tmask = warp.tmask;
-
-  auto opcode = instr.getOpcode();
-  auto func2  = instr.getFunc2();
-  auto func3  = instr.getFunc3();
-  auto func7  = instr.getFunc7();
-  auto rdest  = instr.getRDest();
-  auto rsrc0  = instr.getRSrc(0);
-  auto rsrc1  = instr.getRSrc(1);
-  auto rsrc2  = instr.getRSrc(2);
-  auto immsrc = sext((Word)instr.getImm(), 32);
-
-  auto num_threads = arch_.num_threads();
-
-  uint32_t thread_start = 0;
-  for (; thread_start < num_threads; ++thread_start) {
-      if (warp.tmask.test(thread_start))
-        break;
-  }
-
-  std::vector<reg_data_t[3]> rsdata(num_threads);
-  std::vector<reg_data_t> rddata(num_threads);
-
-  auto num_rsrcs = instr.getNRSrc();
-  if (num_rsrcs) {
-    for (uint32_t i = 0; i < num_rsrcs; ++i) {
-      auto type = instr.getRSType(i);
-      auto reg = instr.getRSrc(i);
-      switch (type) {
-      case RegType::Integer:
-        DPH(2, "Src" << std::dec << i << " Reg: " << type << std::dec << reg << "={");
-        for (uint32_t t = 0; t < num_threads; ++t) {
-          if (t) DPN(2, ", ");
-          if (!warp.tmask.test(t)) {
-            DPN(2, "-");
-            continue;
-          }
-          rsdata[t][i].u = warp.ireg_file.at(t)[reg];
-          DPN(2, "0x" << std::hex << rsdata[t][i].i);
-        }
-        DPN(2, "}" << std::endl);
-        break;
-      case RegType::Float:
-        DPH(2, "Src" << std::dec << i << " Reg: " << type << std::dec << reg << "={");
-        for (uint32_t t = 0; t < num_threads; ++t) {
-          if (t) DPN(2, ", ");
-          if (!warp.tmask.test(t)) {
-            DPN(2, "-");
-            continue;
-          }
-          rsdata[t][i].u64 = warp.freg_file.at(t)[reg];
-          DPN(2, "0x" << std::hex << rsdata[t][i].f);
-        }
-        DPN(2, "}" << std::endl);
-        break;
-      case RegType::None:
-        break;
-      }
-    }
-  }
-
-  bool rd_write = false;
-
-  switch (opcode) {
-  case Opcode::LUI: {
-    // RV32I: LUI
-    trace->fu_type = FUType::ALU;
-    trace->alu_type = AluType::ARITH;
-    for (uint32_t t = thread_start; t < num_threads; ++t) {
-      if (!warp.tmask.test(t))
-        continue;
-      rddata[t].i = immsrc;
-    }
-    rd_write = true;
-    break;
-  }
-  case Opcode::AUIPC: {
-    // RV32I: AUIPC
-    trace->fu_type = FUType::ALU;
-    trace->alu_type = AluType::ARITH;
-    for (uint32_t t = thread_start; t < num_threads; ++t) {
-      if (!warp.tmask.test(t))
-        continue;
-      rddata[t].i = immsrc + warp.PC;
-    }
-    rd_write = true;
-    break;
-  }
-  case Opcode::R: {
-    trace->fu_type = FUType::ALU;
-    trace->alu_type = AluType::ARITH;
-    trace->used_iregs.set(rsrc0);
-    trace->used_iregs.set(rsrc1);
-    for (uint32_t t = thread_start; t < num_threads; ++t) {
-      if (!warp.tmask.test(t))
-        continue;
-      if (func7 & 0x1) {
-        switch (func3) {
-        case 0: {
-          // RV32M: MUL
-          rddata[t].i = rsdata[t][0].i * rsdata[t][1].i;
-          trace->alu_type = AluType::IMUL;
-          break;
-        }
-        case 1: {
-          // RV32M: MULH
-          auto first = static_cast<DWordI>(rsdata[t][0].i);
-          auto second = static_cast<DWordI>(rsdata[t][1].i);
-          rddata[t].i = (first * second) >> XLEN;
-          trace->alu_type = AluType::IMUL;
-          break;
-        }
-        case 2: {
-          // RV32M: MULHSU
-          auto first = static_cast<DWordI>(rsdata[t][0].i);
-          auto second = static_cast<DWord>(rsdata[t][1].u);
-          rddata[t].i = (first * second) >> XLEN;
-          trace->alu_type = AluType::IMUL;
-          break;
-        }
-        case 3: {
-          // RV32M: MULHU
-          auto first = static_cast<DWord>(rsdata[t][0].u);
-          auto second = static_cast<DWord>(rsdata[t][1].u);
-          rddata[t].i = (first * second) >> XLEN;
-          trace->alu_type = AluType::IMUL;
-          break;
-        }
-        case 4: {
-          // RV32M: DIV
-          auto dividen = rsdata[t][0].i;
-          auto divisor = rsdata[t][1].i;
-          auto largest_negative = WordI(1) << (XLEN-1);
-          if (divisor == 0) {
-            rddata[t].i = -1;
-          } else if (dividen == largest_negative && divisor == -1) {
-            rddata[t].i = dividen;
-          } else {
-            rddata[t].i = dividen / divisor;
-          }
-          trace->alu_type = AluType::IDIV;
-          break;
-        }
-        case 5: {
-          // RV32M: DIVU
-          auto dividen = rsdata[t][0].u;
-          auto divisor = rsdata[t][1].u;
-          if (divisor == 0) {
-            rddata[t].i = -1;
-          } else {
-            rddata[t].i = dividen / divisor;
-          }
-          trace->alu_type = AluType::IDIV;
-          break;
-        }
-        case 6: {
-          // RV32M: REM
-          auto dividen = rsdata[t][0].i;
-          auto divisor = rsdata[t][1].i;
-          auto largest_negative = WordI(1) << (XLEN-1);
-          if (rsdata[t][1].i == 0) {
-            rddata[t].i = dividen;
-          } else if (dividen == largest_negative && divisor == -1) {
-            rddata[t].i = 0;
-          } else {
-            rddata[t].i = dividen % divisor;
-          }
-          trace->alu_type = AluType::IDIV;
-          break;
-        }
-        case 7: {
-          // RV32M: REMU
-          auto dividen = rsdata[t][0].u;
-          auto divisor = rsdata[t][1].u;
-          if (rsdata[t][1].i == 0) {
-            rddata[t].i = dividen;
-          } else {
-            rddata[t].i = dividen % divisor;
-          }
-          trace->alu_type = AluType::IDIV;
-          break;
-        }
-        default:
-          std::abort();
-        }
-      } else {
-        switch (func3) {
-        case 0: {
-          if (func7 & 0x20) {
-            // RV32I: SUB
-            rddata[t].i = rsdata[t][0].i - rsdata[t][1].i;
-          } else {
-            // RV32I: ADD
-            rddata[t].i = rsdata[t][0].i + rsdata[t][1].i;
-          }
-          break;
-        }
-        case 1: {
-          // RV32I: SLL
-          Word shamt_mask = (Word(1) << log2up(XLEN)) - 1;
-          Word shamt = rsdata[t][1].i & shamt_mask;
-          rddata[t].i = rsdata[t][0].i << shamt;
-          break;
-        }
-        case 2: {
-          // RV32I: SLT
-          rddata[t].i = rsdata[t][0].i < rsdata[t][1].i;
-          break;
-        }
-        case 3: {
-          // RV32I: SLTU
-          rddata[t].i = rsdata[t][0].u < rsdata[t][1].u;
-          break;
-        }
-        case 4: {
-          // RV32I: XOR
-          rddata[t].i = rsdata[t][0].i ^ rsdata[t][1].i;
-          break;
-        }
-        case 5: {
-          Word shamt_mask = ((Word)1 << log2up(XLEN)) - 1;
-          Word shamt = rsdata[t][1].i & shamt_mask;
-          if (func7 & 0x20) {
-            // RV32I: SRA
-            rddata[t].i = rsdata[t][0].i >> shamt;
-          } else {
-            // RV32I: SRL
-            rddata[t].i = rsdata[t][0].u >> shamt;
-          }
-          break;
-        }
-        case 6: {
-          // RV32I: OR
-          rddata[t].i = rsdata[t][0].i | rsdata[t][1].i;
-          break;
-        }
-        case 7: {
-          // RV32I: AND
-          rddata[t].i = rsdata[t][0].i & rsdata[t][1].i;
-          break;
-        }
-        default:
-          std::abort();
-        }
-      }
-    }
-    rd_write = true;
-    break;
-  }
-  case Opcode::I: {
-    trace->fu_type = FUType::ALU;
-    trace->alu_type = AluType::ARITH;
-    trace->used_iregs.set(rsrc0);
-    for (uint32_t t = thread_start; t < num_threads; ++t) {
-      if (!warp.tmask.test(t))
-        continue;
-      switch (func3) {
-      case 0: {
-        // RV32I: ADDI
-        rddata[t].i = rsdata[t][0].i + immsrc;
-        break;
-      }
-      case 1: {
-        // RV32I: SLLI
-        rddata[t].i = rsdata[t][0].i << immsrc;
-        break;
-      }
-      case 2: {
-        // RV32I: SLTI
-        rddata[t].i = rsdata[t][0].i < WordI(immsrc);
-        break;
-      }
-      case 3: {
-        // RV32I: SLTIU
-        rddata[t].i = rsdata[t][0].u < immsrc;
-        break;
-      }
-      case 4: {
-        // RV32I: XORI
-        rddata[t].i = rsdata[t][0].i ^ immsrc;
-        break;
-      }
-      case 5: {
-        if (func7 & 0x20) {
-          // RV32I: SRAI
-          Word result = rsdata[t][0].i >> immsrc;
-          rddata[t].i = result;
-        } else {
-          // RV32I: SRLI
-          Word result = rsdata[t][0].u >> immsrc;
-          rddata[t].i = result;
-        }
-        break;
-      }
-      case 6: {
-        // RV32I: ORI
-        rddata[t].i = rsdata[t][0].i | immsrc;
-        break;
-      }
-      case 7: {
-        // RV32I: ANDI
-        rddata[t].i = rsdata[t][0].i & immsrc;
-        break;
-      }
-      }
-    }
-    rd_write = true;
-    break;
-  }
-  case Opcode::R_W: {
-    trace->fu_type = FUType::ALU;
-    trace->alu_type = AluType::ARITH;
-    trace->used_iregs.set(rsrc0);
-    trace->used_iregs.set(rsrc1);
-    for (uint32_t t = thread_start; t < num_threads; ++t) {
-      if (!warp.tmask.test(t))
-        continue;
-      if (func7 & 0x1) {
-        switch (func3) {
-          case 0: {
-            // RV64M: MULW
-            int32_t product = (int32_t)rsdata[t][0].i * (int32_t)rsdata[t][1].i;
-            rddata[t].i = sext((uint64_t)product, 32);
-            trace->alu_type = AluType::IMUL;
-            break;
-          }
-          case 4: {
-            // RV64M: DIVW
-            int32_t dividen = (int32_t)rsdata[t][0].i;
-            int32_t divisor = (int32_t)rsdata[t][1].i;
-            int32_t quotient;
-            int32_t largest_negative = 0x80000000;
-            if (divisor == 0){
-              quotient = -1;
-            } else if (dividen == largest_negative && divisor == -1) {
-              quotient = dividen;
-            } else {
-              quotient = dividen / divisor;
-            }
-            rddata[t].i = sext((uint64_t)quotient, 32);
-            trace->alu_type = AluType::IDIV;
-            break;
-          }
-          case 5: {
-            // RV64M: DIVUW
-            uint32_t dividen = (uint32_t)rsdata[t][0].i;
-            uint32_t divisor = (uint32_t)rsdata[t][1].i;
-            uint32_t quotient;
-            if (divisor == 0){
-              quotient = -1;
-            } else {
-              quotient = dividen / divisor;
-            }
-            rddata[t].i = sext((uint64_t)quotient, 32);
-            trace->alu_type = AluType::IDIV;
-            break;
-          }
-          case 6: {
-            // RV64M: REMW
-            int32_t dividen = (uint32_t)rsdata[t][0].i;
-            int32_t divisor = (uint32_t)rsdata[t][1].i;
-            int32_t remainder;
-            int32_t largest_negative = 0x80000000;
-            if (divisor == 0){
-              remainder = dividen;
-            } else if (dividen == largest_negative && divisor == -1) {
-              remainder = 0;
-            } else {
-              remainder = dividen % divisor;
-            }
-            rddata[t].i = sext((uint64_t)remainder, 32);
-            trace->alu_type = AluType::IDIV;
-            break;
-          }
-          case 7: {
-            // RV64M: REMUW
-            uint32_t dividen = (uint32_t)rsdata[t][0].i;
-            uint32_t divisor = (uint32_t)rsdata[t][1].i;
-            uint32_t remainder;
-            if (divisor == 0){
-              remainder = dividen;
-            } else {
-              remainder = dividen % divisor;
-            }
-            rddata[t].i = sext((uint64_t)remainder, 32);
-            trace->alu_type = AluType::IDIV;
-            break;
-          }
-          default:
-            std::abort();
-        }
-      } else {
-        switch (func3) {
-        case 0: {
-          if (func7 & 0x20){
-            // RV64I: SUBW
-            uint32_t result = (uint32_t)rsdata[t][0].i - (uint32_t)rsdata[t][1].i;
-            rddata[t].i = sext((uint64_t)result, 32);
-          }
-          else{
-            // RV64I: ADDW
-            uint32_t result = (uint32_t)rsdata[t][0].i + (uint32_t)rsdata[t][1].i;
-            rddata[t].i = sext((uint64_t)result, 32);
-          }
-          break;
-        }
-        case 1: {
-          // RV64I: SLLW
-          uint32_t shamt_mask = 0x1F;
-          uint32_t shamt = rsdata[t][1].i & shamt_mask;
-          uint32_t result = (uint32_t)rsdata[t][0].i << shamt;
-          rddata[t].i = sext((uint64_t)result, 32);
-          break;
-        }
-        case 5: {
-          uint32_t shamt_mask = 0x1F;
-          uint32_t shamt = rsdata[t][1].i & shamt_mask;
-          uint32_t result;
-          if (func7 & 0x20) {
-            // RV64I: SRAW
-            result = (int32_t)rsdata[t][0].i >> shamt;
-          } else {
-            // RV64I: SRLW
-            result = (uint32_t)rsdata[t][0].i >> shamt;
-          }
-          rddata[t].i = sext((uint64_t)result, 32);
-          break;
-        }
-        default:
-          std::abort();
-        }
-      }
-    }
-    rd_write = true;
-    break;
-  }
-  case Opcode::I_W: {
-    trace->fu_type = FUType::ALU;
-    trace->alu_type = AluType::ARITH;
-    trace->used_iregs.set(rsrc0);
-    for (uint32_t t = thread_start; t < num_threads; ++t) {
-      if (!warp.tmask.test(t))
-        continue;
-      switch (func3) {
-        case 0: {
-          // RV64I: ADDIW
-          uint32_t result = (uint32_t)rsdata[t][0].i + (uint32_t)immsrc;
-          rddata[t].i = sext((uint64_t)result, 32);
-          break;
-        }
-        case 1: {
-          // RV64I: SLLIW
-          uint32_t shamt_mask = 0x1F;
-          uint32_t shamt = immsrc & shamt_mask;
-          uint32_t result = rsdata[t][0].i << shamt;
-          rddata[t].i = sext((uint64_t)result, 32);
-          break;
-        }
-        case 5: {
-          uint32_t shamt_mask = 0x1F;
-          uint32_t shamt = immsrc & shamt_mask;
-          uint32_t result;
-          if (func7 & 0x20) {
-            // RV64I: SRAIW
-            result = (int32_t)rsdata[t][0].i >> shamt;
-          } else {
-            // RV64I: SRLIW
-            result = (uint32_t)rsdata[t][0].i >> shamt;
-          }
-          rddata[t].i = sext((uint64_t)result, 32);
-          break;
-        }
-        default:
-          std::abort();
-      }
-    }
-    rd_write = true;
-    break;
-  }
-  case Opcode::B: {
-    trace->fu_type = FUType::ALU;
-    trace->alu_type = AluType::BRANCH;
-    trace->used_iregs.set(rsrc0);
-    trace->used_iregs.set(rsrc1);
-    bool all_taken = false;
-    for (uint32_t t = thread_start; t < num_threads; ++t) {
-      if (!warp.tmask.test(t))
-        continue;
-      bool curr_taken = false;
-      switch (func3) {
-      case 0: {
-        // RV32I: BEQ
-        if (rsdata[t][0].i == rsdata[t][1].i) {
-          next_pc = warp.PC + immsrc;
-          curr_taken = true;
-        }
-        break;
-      }
-      case 1: {
-        // RV32I: BNE
-        if (rsdata[t][0].i != rsdata[t][1].i) {
-          next_pc = warp.PC + immsrc;
-          curr_taken = true;
-        }
-        break;
-      }
-      case 4: {
-        // RV32I: BLT
-        if (rsdata[t][0].i < rsdata[t][1].i) {
-          next_pc = warp.PC + immsrc;
-          curr_taken = true;
-        }
-        break;
-      }
-      case 5: {
-        // RV32I: BGE
-        if (rsdata[t][0].i >= rsdata[t][1].i) {
-          next_pc = warp.PC + immsrc;
-          curr_taken = true;
-        }
-        break;
-      }
-      case 6: {
-        // RV32I: BLTU
-        if (rsdata[t][0].u < rsdata[t][1].u) {
-          next_pc = warp.PC + immsrc;
-          curr_taken = true;
-        }
-        break;
-      }
-      case 7: {
-        // RV32I: BGEU
-        if (rsdata[t][0].u >= rsdata[t][1].u) {
-          next_pc = warp.PC + immsrc;
-          curr_taken = true;
-        }
-        break;
-      }
-      default:
-        std::abort();
-      }
-      if (t == thread_start) {
-        all_taken = curr_taken;
-      } else {
-        if (all_taken != curr_taken) {
-          std::cout << "divergent branch! PC=0x" << std::hex << warp.PC << " (#" << std::dec << trace->uuid << ")\n" << std::flush;
-          std::abort();
-        }
-      }
-    }
-    trace->fetch_stall = true;
-    break;
-  }
-  case Opcode::JAL: {
-    // RV32I: JAL
-    trace->fu_type = FUType::ALU;
-    trace->alu_type = AluType::BRANCH;
-    for (uint32_t t = thread_start; t < num_threads; ++t) {
-      if (!warp.tmask.test(t))
-        continue;
-      rddata[t].i = next_pc;
-    }
-    next_pc = warp.PC + immsrc;
-    trace->fetch_stall = true;
-    rd_write = true;
-    break;
-  }
-  case Opcode::JALR: {
-    // RV32I: JALR
-    trace->fu_type = FUType::ALU;
-    trace->alu_type = AluType::BRANCH;
-    trace->used_iregs.set(rsrc0);
-    for (uint32_t t = thread_start; t < num_threads; ++t) {
-      if (!warp.tmask.test(t))
-        continue;
-      rddata[t].i = next_pc;
-    }
-    next_pc = rsdata[thread_start][0].i + immsrc;
-    trace->fetch_stall = true;
-    rd_write = true;
-    break;
-  }
-  case Opcode::L:
-  case Opcode::FL: {
-    trace->fu_type = FUType::LSU;
-    trace->lsu_type = LsuType::LOAD;
-    trace->used_iregs.set(rsrc0);
-    auto trace_data = std::make_shared<LsuTraceData>(num_threads);
-    trace->data = trace_data;
-    uint32_t data_bytes = 1 << (func3 & 0x3);
-    uint32_t data_width = 8 * data_bytes;
-    for (uint32_t t = thread_start; t < num_threads; ++t) {
-      if (!warp.tmask.test(t))
-        continue;
-      uint64_t mem_addr = rsdata[t][0].i + immsrc;
-      uint64_t read_data = 0;
-      this->dcache_read(&read_data, mem_addr, data_bytes);
-      trace_data->mem_addrs.at(t) = {mem_addr, data_bytes};
-      switch (func3) {
-      case 0: // RV32I: LB
-      case 1: // RV32I: LH
-        rddata[t].i = sext((Word)read_data, data_width);
-        break;
-      case 2:
-        if (opcode == Opcode::L) {
-          // RV32I: LW
-          rddata[t].i = sext((Word)read_data, data_width);
-        } else {
-          // RV32F: FLW
-          rddata[t].u64 = nan_box((uint32_t)read_data);
-        }
-        break;
-      case 3: // RV64I: LD
-              // RV32D: FLD
-      case 4: // RV32I: LBU
-      case 5: // RV32I: LHU
-      case 6: // RV64I: LWU
-        rddata[t].u64 = read_data;
-        break;
-      default:
-        std::abort();
-      }
-    }
-    rd_write = true;
-    break;
-  }
-  case Opcode::S:
-  case Opcode::FS: {
-    trace->fu_type = FUType::LSU;
-    trace->lsu_type = LsuType::STORE;
-    trace->used_iregs.set(rsrc0);
-    trace->used_iregs.set(rsrc1);
-    auto trace_data = std::make_shared<LsuTraceData>(num_threads);
-    trace->data = trace_data;
-    uint32_t data_bytes = 1 << (func3 & 0x3);
-    for (uint32_t t = thread_start; t < num_threads; ++t) {
-      if (!warp.tmask.test(t))
-        continue;
-      uint64_t mem_addr = rsdata[t][0].i + immsrc;
-      uint64_t write_data = rsdata[t][1].u64;
-      trace_data->mem_addrs.at(t) = {mem_addr, data_bytes};
-      switch (func3) {
-      case 0:
-      case 1:
-      case 2:
-      case 3:
-        this->dcache_write(&write_data, mem_addr, data_bytes);
-        break;
-      default:
-        std::abort();
-      }
-    }
-    break;
-  }
-  case Opcode::AMO: {
-    trace->fu_type = FUType::LSU;
-    trace->lsu_type = LsuType::LOAD;
-    trace->used_iregs.set(rsrc0);
-    trace->used_iregs.set(rsrc1);
-    auto trace_data = std::make_shared<LsuTraceData>(num_threads);
-    trace->data = trace_data;
-    auto amo_type = func7 >> 2;
-    uint32_t data_bytes = 1 << (func3 & 0x3);
-    uint32_t data_width = 8 * data_bytes;
-    for (uint32_t t = thread_start; t < num_threads; ++t) {
-      if (!warp.tmask.test(t))
-        continue;
-      uint64_t mem_addr = rsdata[t][0].u;
-      trace_data->mem_addrs.at(t) = {mem_addr, data_bytes};
-      if (amo_type == 0x02) { // LR
-        uint64_t read_data = 0;
-        this->dcache_read(&read_data, mem_addr, data_bytes);
-        this->dcache_amo_reserve(mem_addr);
-        rddata[t].i = sext((Word)read_data, data_width);
-      } else
-      if (amo_type == 0x03) { // SC
-        if (this->dcache_amo_check(mem_addr)) {
-          this->dcache_write(&rsdata[t][1].u64, mem_addr, data_bytes);
-          rddata[t].i = 0;
-        } else {
-          rddata[t].i = 1;
-        }
-      } else {
-        uint64_t read_data = 0;
-        this->dcache_read(&read_data, mem_addr, data_bytes);
-        auto read_data_i = sext((WordI)read_data, data_width);
-        auto rs1_data_i  = sext((WordI)rsdata[t][1].u64, data_width);
-        auto read_data_u = zext((Word)read_data, data_width);
-        auto rs1_data_u  = zext((Word)rsdata[t][1].u64, data_width);
-        uint64_t result;
-        switch (amo_type) {
-        case 0x00:  // AMOADD
-          result = read_data_i + rs1_data_i;
-          break;
-        case 0x01:  // AMOSWAP
-          result = rs1_data_u;
-          break;
-        case 0x04:  // AMOXOR
-          result = read_data_u ^ rs1_data_u;
-          break;
-        case 0x08:  // AMOOR
-          result = read_data_u | rs1_data_u;
-          break;
-        case 0x0c:  // AMOAND
-          result = read_data_u & rs1_data_u;
-          break;
-        case 0x10:  // AMOMIN
-          result = std::min(read_data_i, rs1_data_i);
-          break;
-        case 0x14:  // AMOMAX
-          result = std::max(read_data_i, rs1_data_i);
-          break;
-        case 0x18:  // AMOMINU
-          result = std::min(read_data_u, rs1_data_u);
-          break;
-        case 0x1c:  // AMOMAXU
-          result = std::max(read_data_u, rs1_data_u);
-          break;
-        default:
-          std::abort();
-        }
-        this->dcache_write(&result, mem_addr, data_bytes);
-        rddata[t].i = read_data_i;
-      }
-    }
-    rd_write = true;
-    break;
-  }
-  case Opcode::SYS: {
-    for (uint32_t t = thread_start; t < num_threads; ++t) {
-      if (!warp.tmask.test(t))
-        continue;
-      uint32_t csr_addr = immsrc;
-      Word csr_value;
-      if (func3 == 0) {
-        trace->fu_type = FUType::ALU;
-        trace->alu_type = AluType::SYSCALL;
-        trace->fetch_stall = true;
-        switch (csr_addr) {
-        case 0:
-          // RV32I: ECALL
-          this->trigger_ecall();
-          break;
-        case 1:
-          // RV32I: EBREAK
-          this->trigger_ebreak();
-          break;
-        case 0x002: // URET
-        case 0x102: // SRET
-        case 0x302: // MRET
-          break;
-        default:
-          std::abort();
-        }
-      } else {
-        trace->fu_type = FUType::SFU;
-        trace->fetch_stall = true;
-        csr_value = this->get_csr(csr_addr, t, wid);
-        switch (func3) {
-        case 1: {
-          // RV32I: CSRRW
-          rddata[t].i = csr_value;
-          this->set_csr(csr_addr, rsdata[t][0].i, t, wid);
-          trace->used_iregs.set(rsrc0);
-          trace->sfu_type = SfuType::CSRRW;
-          rd_write = true;
-          break;
-        }
-        case 2: {
-          // RV32I: CSRRS
-          rddata[t].i = csr_value;
-          if (rsdata[t][0].i != 0) {
-            this->set_csr(csr_addr, csr_value | rsdata[t][0].i, t, wid);
-          }
-          trace->used_iregs.set(rsrc0);
-          trace->sfu_type = SfuType::CSRRS;
-          rd_write = true;
-          break;
-        }
-        case 3: {
-          // RV32I: CSRRC
-          rddata[t].i = csr_value;
-          if (rsdata[t][0].i != 0) {
-            this->set_csr(csr_addr, csr_value & ~rsdata[t][0].i, t, wid);
-          }
-          trace->used_iregs.set(rsrc0);
-          trace->sfu_type = SfuType::CSRRC;
-          rd_write = true;
-          break;
-        }
-        case 5: {
-          // RV32I: CSRRWI
-          rddata[t].i = csr_value;
-          this->set_csr(csr_addr, rsrc0, t, wid);
-          trace->sfu_type = SfuType::CSRRW;
-          rd_write = true;
-          break;
-        }
-        case 6: {
-          // RV32I: CSRRSI;
-          rddata[t].i = csr_value;
-          if (rsrc0 != 0) {
-            this->set_csr(csr_addr, csr_value | rsrc0, t, wid);
-          }
-          trace->sfu_type = SfuType::CSRRS;
-          rd_write = true;
-          break;
-        }
-        case 7: {
-          // RV32I: CSRRCI
-          rddata[t].i = csr_value;
-          if (rsrc0 != 0) {
-            this->set_csr(csr_addr, csr_value & ~rsrc0, t, wid);
-          }
-          trace->sfu_type = SfuType::CSRRC;
-          rd_write = true;
-          break;
-        }
-        default:
-          break;
-        }
-      }
-    }
-    break;
-  }
-  case Opcode::FENCE: {
-    // RV32I: FENCE
-    trace->fu_type = FUType::LSU;
-    trace->lsu_type = LsuType::FENCE;
-    break;
-  }
-  case Opcode::FCI: {
-    trace->fu_type = FUType::FPU;
-    for (uint32_t t = thread_start; t < num_threads; ++t) {
-      if (!warp.tmask.test(t))
-        continue;
-      uint32_t frm = this->get_fpu_rm(func3, t, wid);
-      uint32_t fflags = 0;
-      switch (func7) {
-      case 0x00: { // RV32F: FADD.S
-        rddata[t].u64 = nan_box(rv_fadd_s(check_boxing(rsdata[t][0].u64), check_boxing(rsdata[t][1].u64), frm, &fflags));
-        trace->fpu_type = FpuType::FMA;
-        trace->used_fregs.set(rsrc0);
-        trace->used_fregs.set(rsrc1);
-        break;
-      }
-      case 0x01: { // RV32D: FADD.D
-        rddata[t].u64 = rv_fadd_d(rsdata[t][0].u64, rsdata[t][1].u64, frm, &fflags);
-        trace->fpu_type = FpuType::FMA;
-        trace->used_fregs.set(rsrc0);
-        trace->used_fregs.set(rsrc1);
-        break;
-      }
-      case 0x04: { // RV32F: FSUB.S
-        rddata[t].u64 = nan_box(rv_fsub_s(check_boxing(rsdata[t][0].u64), check_boxing(rsdata[t][1].u64), frm, &fflags));
-        trace->fpu_type = FpuType::FMA;
-        trace->used_fregs.set(rsrc0);
-        trace->used_fregs.set(rsrc1);
-        break;
-      }
-      case 0x05: { // RV32D: FSUB.D
-        rddata[t].u64 = rv_fsub_d(rsdata[t][0].u64, rsdata[t][1].u64, frm, &fflags);
-        trace->fpu_type = FpuType::FMA;
-        trace->used_fregs.set(rsrc0);
-        trace->used_fregs.set(rsrc1);
-        break;
-      }
-      case 0x08: { // RV32F: FMUL.S
-        rddata[t].u64 = nan_box(rv_fmul_s(check_boxing(rsdata[t][0].u64), check_boxing(rsdata[t][1].u64), frm, &fflags));
-        trace->fpu_type = FpuType::FMA;
-        trace->used_fregs.set(rsrc0);
-        trace->used_fregs.set(rsrc1);
-        break;
-      }
-      case 0x09: { // RV32D: FMUL.D
-        rddata[t].u64 = rv_fmul_d(rsdata[t][0].u64, rsdata[t][1].u64, frm, &fflags);
-        trace->fpu_type = FpuType::FMA;
-        trace->used_fregs.set(rsrc0);
-        trace->used_fregs.set(rsrc1);
-        break;
-      }
-      case 0x0c: { // RV32F: FDIV.S
-        rddata[t].u64 = nan_box(rv_fdiv_s(check_boxing(rsdata[t][0].u64), check_boxing(rsdata[t][1].u64), frm, &fflags));
-        trace->fpu_type = FpuType::FDIV;
-        trace->used_fregs.set(rsrc0);
-        trace->used_fregs.set(rsrc1);
-        break;
-      }
-      case 0x0d: { // RV32D: FDIV.D
-        rddata[t].u64 = rv_fdiv_d(rsdata[t][0].u64, rsdata[t][1].u64, frm, &fflags);
-        trace->fpu_type = FpuType::FDIV;
-        trace->used_fregs.set(rsrc0);
-        trace->used_fregs.set(rsrc1);
-        break;
-      }
-      case 0x10: {
-        switch (func3) {
-        case 0: // RV32F: FSGNJ.S
-          rddata[t].u64 = nan_box(rv_fsgnj_s(check_boxing(rsdata[t][0].u64), check_boxing(rsdata[t][1].u64)));
-          break;
-        case 1: // RV32F: FSGNJN.S
-          rddata[t].u64 = nan_box(rv_fsgnjn_s(check_boxing(rsdata[t][0].u64), check_boxing(rsdata[t][1].u64)));
-          break;
-        case 2: // RV32F: FSGNJX.S
-          rddata[t].u64 = nan_box(rv_fsgnjx_s(check_boxing(rsdata[t][0].u64), check_boxing(rsdata[t][1].u64)));
-          break;
-        }
-        trace->fpu_type = FpuType::FNCP;
-        trace->used_fregs.set(rsrc0);
-        trace->used_fregs.set(rsrc1);
-        break;
-      }
-      case 0x11: {
-        switch (func3) {
-        case 0: // RV32D: FSGNJ.D
-          rddata[t].u64 = rv_fsgnj_d(rsdata[t][0].u64, rsdata[t][1].u64);
-          break;
-        case 1: // RV32D: FSGNJN.D
-          rddata[t].u64 = rv_fsgnjn_d(rsdata[t][0].u64, rsdata[t][1].u64);
-          break;
-        case 2: // RV32D: FSGNJX.D
-          rddata[t].u64 = rv_fsgnjx_d(rsdata[t][0].u64, rsdata[t][1].u64);
-          break;
-        }
-        trace->fpu_type = FpuType::FNCP;
-        trace->used_fregs.set(rsrc0);
-        trace->used_fregs.set(rsrc1);
-        break;
-      }
-      case 0x14: {
-        if (func3) {
-          // RV32F: FMAX.S
-          rddata[t].u64 = nan_box(rv_fmax_s(check_boxing(rsdata[t][0].u64), check_boxing(rsdata[t][1].u64), &fflags));
-        } else {
-          // RV32F: FMIN.S
-          rddata[t].u64 = nan_box(rv_fmin_s(check_boxing(rsdata[t][0].u64), check_boxing(rsdata[t][1].u64), &fflags));
-        }
-        trace->fpu_type = FpuType::FNCP;
-        trace->used_fregs.set(rsrc0);
-        trace->used_fregs.set(rsrc1);
-        break;
-      }
-      case 0x15: {
-        if (func3) {
-          // RV32D: FMAX.D
-          rddata[t].u64 = rv_fmax_d(rsdata[t][0].u64, rsdata[t][1].u64, &fflags);
-        } else {
-          // RV32D: FMIN.D
-          rddata[t].u64 = rv_fmin_d(rsdata[t][0].u64, rsdata[t][1].u64, &fflags);
-        }
-        trace->fpu_type = FpuType::FNCP;
-        trace->used_fregs.set(rsrc0);
-        trace->used_fregs.set(rsrc1);
-        break;
-      }
-      case 0x20: {
-        // RV32D: FCVT.S.D
-        rddata[t].u64 = nan_box(rv_dtof(rsdata[t][0].u64));
-        trace->fpu_type = FpuType::FNCP;
-        trace->used_fregs.set(rsrc0);
-        break;
-      }
-      case 0x21: {
-        // RV32D: FCVT.D.S
-        rddata[t].u64 = rv_ftod(check_boxing(rsdata[t][0].u64));
-        trace->fpu_type = FpuType::FNCP;
-        trace->used_fregs.set(rsrc0);
-        break;
-      }
-      case 0x2c: { // RV32F: FSQRT.S
-        rddata[t].u64 = nan_box(rv_fsqrt_s(check_boxing(rsdata[t][0].u64), frm, &fflags));
-        trace->fpu_type = FpuType::FSQRT;
-        trace->used_fregs.set(rsrc0);
-        break;
-      }
-      case 0x2d: { // RV32D: FSQRT.D
-        rddata[t].u64 = rv_fsqrt_d(rsdata[t][0].u64, frm, &fflags);
-        trace->fpu_type = FpuType::FSQRT;
-        trace->used_fregs.set(rsrc0);
-        break;
-      }
-      case 0x50: {
-        switch (func3) {
-        case 0:
-          // RV32F: FLE.S
-          rddata[t].i = rv_fle_s(check_boxing(rsdata[t][0].u64), check_boxing(rsdata[t][1].u64), &fflags);
-          break;
-        case 1:
-          // RV32F: FLT.S
-          rddata[t].i = rv_flt_s(check_boxing(rsdata[t][0].u64), check_boxing(rsdata[t][1].u64), &fflags);
-          break;
-        case 2:
-          // RV32F: FEQ.S
-          rddata[t].i = rv_feq_s(check_boxing(rsdata[t][0].u64), check_boxing(rsdata[t][1].u64), &fflags);
-          break;
-        }
-        trace->fpu_type = FpuType::FNCP;
-        trace->used_fregs.set(rsrc0);
-        trace->used_fregs.set(rsrc1);
-        break;
-      }
-      case 0x51: {
-        switch (func3) {
-        case 0:
-          // RV32D: FLE.D
-          rddata[t].i = rv_fle_d(rsdata[t][0].u64, rsdata[t][1].u64, &fflags);
-          break;
-        case 1:
-          // RV32D: FLT.D
-          rddata[t].i = rv_flt_d(rsdata[t][0].u64, rsdata[t][1].u64, &fflags);
-          break;
-        case 2:
-          // RV32D: FEQ.D
-          rddata[t].i = rv_feq_d(rsdata[t][0].u64, rsdata[t][1].u64, &fflags);
-          break;
-        }
-        trace->fpu_type = FpuType::FNCP;
-        trace->used_fregs.set(rsrc0);
-        trace->used_fregs.set(rsrc1);
-        break;
-      }
-      case 0x60: {
-        switch (rsrc1) {
-        case 0:
-          // RV32F: FCVT.W.S
-          rddata[t].i = sext((uint64_t)rv_ftoi_s(check_boxing(rsdata[t][0].u64), frm, &fflags), 32);
-          break;
-        case 1:
-          // RV32F: FCVT.WU.S
-          rddata[t].i = sext((uint64_t)rv_ftou_s(check_boxing(rsdata[t][0].u64), frm, &fflags), 32);
-          break;
-        case 2:
-          // RV64F: FCVT.L.S
-          rddata[t].i = rv_ftol_s(check_boxing(rsdata[t][0].u64), frm, &fflags);
-          break;
-        case 3:
-          // RV64F: FCVT.LU.S
-          rddata[t].i = rv_ftolu_s(check_boxing(rsdata[t][0].u64), frm, &fflags);
-          break;
-        }
-        trace->fpu_type = FpuType::FCVT;
-        trace->used_fregs.set(rsrc0);
-        break;
-      }
-      case 0x61: {
-        switch (rsrc1) {
-        case 0:
-          // RV32D: FCVT.W.D
-          rddata[t].i = sext((uint64_t)rv_ftoi_d(rsdata[t][0].u64, frm, &fflags), 32);
-          break;
-        case 1:
-          // RV32D: FCVT.WU.D
-          rddata[t].i = sext((uint64_t)rv_ftou_d(rsdata[t][0].u64, frm, &fflags), 32);
-          break;
-        case 2:
-          // RV64D: FCVT.L.D
-          rddata[t].i = rv_ftol_d(rsdata[t][0].u64, frm, &fflags);
-          break;
-        case 3:
-          // RV64D: FCVT.LU.D
-          rddata[t].i = rv_ftolu_d(rsdata[t][0].u64, frm, &fflags);
-          break;
-        }
-        trace->fpu_type = FpuType::FCVT;
-        trace->used_fregs.set(rsrc0);
-        break;
-      }
-      case 0x68: {
-        switch (rsrc1) {
-        case 0:
-          // RV32F: FCVT.S.W
-          rddata[t].u64 = nan_box(rv_itof_s(rsdata[t][0].i, frm, &fflags));
-          break;
-        case 1:
-          // RV32F: FCVT.S.WU
-          rddata[t].u64 = nan_box(rv_utof_s(rsdata[t][0].i, frm, &fflags));
-          break;
-        case 2:
-          // RV64F: FCVT.S.L
-          rddata[t].u64 = nan_box(rv_ltof_s(rsdata[t][0].i, frm, &fflags));
-          break;
-        case 3:
-          // RV64F: FCVT.S.LU
-          rddata[t].u64 = nan_box(rv_lutof_s(rsdata[t][0].i, frm, &fflags));
-          break;
-        }
-        trace->fpu_type = FpuType::FCVT;
-        trace->used_iregs.set(rsrc0);
-        break;
-      }
-      case 0x69: {
-        switch (rsrc1) {
-        case 0:
-          // RV32D: FCVT.D.W
-          rddata[t].u64 = rv_itof_d(rsdata[t][0].i, frm, &fflags);
-          break;
-        case 1:
-          // RV32D: FCVT.D.WU
-          rddata[t].u64 = rv_utof_d(rsdata[t][0].i, frm, &fflags);
-          break;
-        case 2:
-          // RV64D: FCVT.D.L
-          rddata[t].u64 = rv_ltof_d(rsdata[t][0].i, frm, &fflags);
-          break;
-        case 3:
-          // RV64D: FCVT.D.LU
-          rddata[t].u64 = rv_lutof_d(rsdata[t][0].i, frm, &fflags);
-          break;
-        }
-        trace->fpu_type = FpuType::FCVT;
-        trace->used_iregs.set(rsrc0);
-        break;
-      }
-      case 0x70: {
-        if (func3) {
-          // RV32F: FCLASS.S
-          rddata[t].i = rv_fclss_s(check_boxing(rsdata[t][0].u64));
-        } else {
-          // RV32F: FMV.X.S
-          uint32_t result = (uint32_t)rsdata[t][0].u64;
-          rddata[t].i = sext((uint64_t)result, 32);
-        }
-        trace->fpu_type = FpuType::FNCP;
-        trace->used_fregs.set(rsrc0);
-        break;
-      }
-      case 0x71: {
-        if (func3) {
-          // RV32D: FCLASS.D
-          rddata[t].i = rv_fclss_d(rsdata[t][0].u64);
-        } else {
-          // RV64D: FMV.X.D
-          rddata[t].i = rsdata[t][0].u64;
-        }
-        trace->fpu_type = FpuType::FNCP;
-        trace->used_fregs.set(rsrc0);
-        break;
-      }
-      case 0x78: { // RV32F: FMV.S.X
-        rddata[t].u64 = nan_box((uint32_t)rsdata[t][0].i);
-        trace->fpu_type = FpuType::FNCP;
-        trace->used_iregs.set(rsrc0);
-        break;
-      }
-      case 0x79: { // RV64D: FMV.D.X
-        rddata[t].u64 = rsdata[t][0].i;
-        trace->fpu_type = FpuType::FNCP;
-        trace->used_iregs.set(rsrc0);
-        break;
-      }
-      }
-      this->update_fcrs(fflags, t, wid);
-    }
-    rd_write = true;
-    break;
-  }
-  case Opcode::FMADD:
-  case Opcode::FMSUB:
-  case Opcode::FMNMADD:
-  case Opcode::FMNMSUB: {
-    trace->fpu_type = FpuType::FMA;
-    trace->used_fregs.set(rsrc0);
-    trace->used_fregs.set(rsrc1);
-    trace->used_fregs.set(rsrc2);
-    for (uint32_t t = thread_start; t < num_threads; ++t) {
-      if (!warp.tmask.test(t))
-        continue;
-      uint32_t frm = this->get_fpu_rm(func3, t, wid);
-      uint32_t fflags = 0;
-      switch (opcode) {
-      case Opcode::FMADD:
-        if (func2)
-          // RV32D: FMADD.D
-          rddata[t].u64 = rv_fmadd_d(rsdata[t][0].u64, rsdata[t][1].u64, rsdata[t][2].u64, frm, &fflags);
-        else
-          // RV32F: FMADD.S
-          rddata[t].u64 = nan_box(rv_fmadd_s(check_boxing(rsdata[t][0].u64), check_boxing(rsdata[t][1].u64), check_boxing(rsdata[t][2].u64), frm, &fflags));
-        break;
-      case Opcode::FMSUB:
-        if (func2)
-          // RV32D: FMSUB.D
-          rddata[t].u64 = rv_fmsub_d(rsdata[t][0].u64, rsdata[t][1].u64, rsdata[t][2].u64, frm, &fflags);
-        else
-          // RV32F: FMSUB.S
-          rddata[t].u64 = nan_box(rv_fmsub_s(check_boxing(rsdata[t][0].u64), check_boxing(rsdata[t][1].u64), check_boxing(rsdata[t][2].u64), frm, &fflags));
-        break;
-      case Opcode::FMNMADD:
-        if (func2)
-          // RV32D: FNMADD.D
-          rddata[t].u64 = rv_fnmadd_d(rsdata[t][0].u64, rsdata[t][1].u64, rsdata[t][2].u64, frm, &fflags);
-        else
-          // RV32F: FNMADD.S
-          rddata[t].u64 = nan_box(rv_fnmadd_s(check_boxing(rsdata[t][0].u64), check_boxing(rsdata[t][1].u64), check_boxing(rsdata[t][2].u64), frm, &fflags));
-        break;
-      case Opcode::FMNMSUB:
-        if (func2)
-          // RV32D: FNMSUB.D
-          rddata[t].u64 = rv_fnmsub_d(rsdata[t][0].u64, rsdata[t][1].u64, rsdata[t][2].u64, frm, &fflags);
-        else
-          // RV32F: FNMSUB.S
-          rddata[t].u64 = nan_box(rv_fnmsub_s(check_boxing(rsdata[t][0].u64), check_boxing(rsdata[t][1].u64), check_boxing(rsdata[t][2].u64), frm, &fflags));
-        break;
-      default:
-        break;
-      }
-      this->update_fcrs(fflags, t, wid);
-    }
-    rd_write = true;
-    break;
-  }
-  case Opcode::EXT1: {
-    switch (func7) {
-    case 0: {
-      switch (func3) {
-      case 0: {
-        // TMC
-        trace->fu_type = FUType::SFU;
-        trace->sfu_type = SfuType::TMC;
-        trace->used_iregs.set(rsrc0);
-        trace->fetch_stall = true;
-        next_tmask.reset();
-        for (uint32_t t = 0; t < num_threads; ++t) {
-          next_tmask.set(t, rsdata.at(thread_start)[0].i & (1 << t));
-        }
-      } break;
-      case 1: {
-        // WSPAWN
-        trace->fu_type = FUType::SFU;
-        trace->sfu_type = SfuType::WSPAWN;
-        trace->used_iregs.set(rsrc0);
-        trace->used_iregs.set(rsrc1);
-        trace->fetch_stall = true;
-        trace->data = std::make_shared<SFUTraceData>(rsdata.at(thread_start)[0].i, rsdata.at(thread_start)[1].i);
-      } break;
-      case 2: {
-        // SPLIT
-        trace->fu_type = FUType::SFU;
-        trace->sfu_type = SfuType::SPLIT;
-        trace->used_iregs.set(rsrc0);
-        trace->fetch_stall = true;
-
-        auto stack_size = warp.ipdom_stack.size();
-
-        ThreadMask then_tmask, else_tmask;
-        auto not_pred = rsrc2 & 0x1;
-        for (uint32_t t = 0; t < num_threads; ++t) {
-          auto cond = (warp.ireg_file.at(t).at(rsrc0) & 0x1) ^ not_pred;
-          then_tmask[t] = warp.tmask.test(t) && cond;
-          else_tmask[t] = warp.tmask.test(t) && !cond;
-        }
-
-        bool is_divergent = then_tmask.any() && else_tmask.any();
-        if (is_divergent) {
-          if (stack_size == arch_.ipdom_size()) {
-            std::cout << "IPDOM stack is full! size=" << std::dec << stack_size << ", PC=0x" << std::hex << warp.PC << " (#" << std::dec << trace->uuid << ")\n" << std::flush;
-            std::abort();
-          }
-          // set new thread mask to the larger set
-          if (then_tmask.count() >= else_tmask.count()) {
-            next_tmask = then_tmask;
-          } else {
-            next_tmask = else_tmask;
-          }
-          // push reconvergence thread mask onto the stack
-          warp.ipdom_stack.emplace(warp.tmask);
-          // push not taken thread mask onto the stack
-          auto ntaken_tmask = ~next_tmask & warp.tmask;
-          warp.ipdom_stack.emplace(ntaken_tmask, next_pc);
-        }
-        // return divergent state
-        for (uint32_t t = thread_start; t < num_threads; ++t) {
-          rddata[t].i = stack_size;
-        }
-        rd_write = true;
-      } break;
-      case 3: {
-        // JOIN
-        trace->fu_type = FUType::SFU;
-        trace->sfu_type = SfuType::JOIN;
-        trace->used_iregs.set(rsrc0);
-        trace->fetch_stall = true;
-
-        auto stack_ptr = warp.ireg_file.at(thread_start).at(rsrc0);
-        if (stack_ptr != warp.ipdom_stack.size()) {
-          if (warp.ipdom_stack.empty()) {
-            std::cout << "IPDOM stack is empty!\n" << std::flush;
-            std::abort();
-          }
-          next_tmask = warp.ipdom_stack.top().tmask;
-          if (!warp.ipdom_stack.top().fallthrough) {
-            next_pc = warp.ipdom_stack.top().PC;
-          }
-          warp.ipdom_stack.pop();
-        }
-      } break;
-      case 4: {
-        // BAR
-        trace->fu_type = FUType::SFU;
-        trace->sfu_type = SfuType::BAR;
-        trace->used_iregs.set(rsrc0);
-        trace->used_iregs.set(rsrc1);
-        trace->fetch_stall = true;
-        trace->data = std::make_shared<SFUTraceData>(rsdata[thread_start][0].i, rsdata[thread_start][1].i);
-      } break;
-      case 5: {
-        // PRED
-        trace->fu_type = FUType::SFU;
-        trace->sfu_type = SfuType::PRED;
-        trace->used_iregs.set(rsrc0);
-        trace->used_iregs.set(rsrc1);
-        trace->fetch_stall = true;
-        ThreadMask pred;
-        auto not_pred = rdest & 0x1;
-        for (uint32_t t = 0; t < num_threads; ++t) {
-          auto cond = (warp.ireg_file.at(t).at(rsrc0) & 0x1) ^ not_pred;
-          pred[t] = warp.tmask.test(t) && cond;
-        }
-        if (pred.any()) {
-          next_tmask &= pred;
-        } else {
-          next_tmask = warp.ireg_file.at(thread_start).at(rsrc1);
-        }
-      } break;
-      default:
-        std::abort();
-      }
-    } break;
-    default:
-      std::abort();
-    }
-  } break;
-  case Opcode::EXT2: {
-    switch (func3) {
-    case 1:
-      switch (func2) {
-      case 0: { // CMOV
-        trace->fu_type = FUType::SFU;
-        trace->sfu_type = SfuType::CMOV;
-        trace->used_iregs.set(rsrc0);
-        trace->used_iregs.set(rsrc1);
-        trace->used_iregs.set(rsrc2);
-        for (uint32_t t = thread_start; t < num_threads; ++t) {
-          if (!warp.tmask.test(t))
-            continue;
-          rddata[t].i = rsdata[t][0].i ? rsdata[t][1].i : rsdata[t][2].i;
-        }
-        rd_write = true;
-      } break;
-      default:
-        std::abort();
-      }
-      break;
-    default:
-      std::abort();
-    }
-  } break;
-  default:
-    std::abort();
-  }
-
-  if (rd_write) {
-    trace->wb = true;
-    auto type = instr.getRDType();
-    switch (type) {
-    case RegType::Integer:
-      if (rdest) {
-        DPH(2, "Dest Reg: " << type << std::dec << rdest << "={");
-        for (uint32_t t = 0; t < num_threads; ++t) {
-          if (t) DPN(2, ", ");
-          if (!warp.tmask.test(t)) {
-            DPN(2, "-");
-            continue;
-          }
-          warp.ireg_file.at(t)[rdest] = rddata[t].i;
-          DPN(2, "0x" << std::hex << rddata[t].i);
-        }
-        DPN(2, "}" << std::endl);
-        trace->used_iregs[rdest] = 1;
-        assert(rdest != 0);
-      } else {
-        // disable writes to x0
-        trace->wb = false;
-      }
-      break;
-    case RegType::Float:
-      DPH(2, "Dest Reg: " << type << std::dec << rdest << "={");
-      for (uint32_t t = 0; t < num_threads; ++t) {
-        if (t) DPN(2, ", ");
-        if (!warp.tmask.test(t)) {
-          DPN(2, "-");
-          continue;
-        }
-        warp.freg_file.at(t)[rdest] = rddata[t].u64;
-        DPN(2, "0x" << std::hex << rddata[t].f);
-      }
-      DPN(2, "}" << std::endl);
-      trace->used_fregs[rdest] = 1;
-      break;
-    default:
-      std::abort();
-      break;
-    }
-  }
-
-  warp.PC += 4;
-
-  if (warp.PC != next_pc) {
-    DP(3, "*** Next PC=0x" << std::hex << next_pc << std::dec);
-    warp.PC = next_pc;
-  }
-
-  if (warp.tmask != next_tmask) {
-    DPH(3, "*** New Tmask=");
-    for (uint32_t i = 0; i < num_threads; ++i)
-      DPN(3, next_tmask.test(i));
-    DPN(3, std::endl);
-    warp.tmask = next_tmask;
-    if (!next_tmask.any()) {
-      active_warps_.reset(wid);
-    }
-  }
+// Copyright © 2019-2023
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#include <iostream>
+#include <stdlib.h>
+#include <unistd.h>
+#include <math.h>
+#include <bitset>
+#include <climits>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <assert.h>
+#include <util.h>
+#include <rvfloats.h>
+#include "emulator.h"
+#include "instr.h"
+#include "core.h"
+
+using namespace vortex;
+
+union reg_data_t {
+  Word     u;
+  WordI    i;
+  WordF    f;
+  float    f32;
+  double   f64;
+  uint32_t u32;
+  uint64_t u64;
+  int32_t  i32;
+  int64_t  i64;
+};
+
+inline uint64_t nan_box(uint32_t value) {
+  uint64_t mask = 0xffffffff00000000;
+  return value | mask;
+}
+
+inline bool is_nan_boxed(uint64_t value) {
+  return (uint32_t(value >> 32) == 0xffffffff);
+}
+
+inline int64_t check_boxing(int64_t a) {
+  if (is_nan_boxed(a))
+    return a;
+  return nan_box(0x7fc00000); // NaN
+}
+
+void Emulator::execute(const Instr &instr, uint32_t wid, instr_trace_t *trace) {
+  auto& warp = warps_.at(wid);
+  assert(warp.tmask.any());
+
+  // initialize instruction trace
+  trace->cid   = core_->id();
+  trace->wid   = wid;
+  trace->PC    = warp.PC;
+  trace->tmask = warp.tmask;
+  trace->rdest = instr.getRDest();
+  trace->rdest_type = instr.getRDType();
+
+  auto next_pc = warp.PC + 4;
+  auto next_tmask = warp.tmask;
+
+  auto opcode = instr.getOpcode();
+  auto func2  = instr.getFunc2();
+  auto func3  = instr.getFunc3();
+  auto func7  = instr.getFunc7();
+  auto rdest  = instr.getRDest();
+  auto rsrc0  = instr.getRSrc(0);
+  auto rsrc1  = instr.getRSrc(1);
+  auto rsrc2  = instr.getRSrc(2);
+  auto immsrc = sext((Word)instr.getImm(), 32);
+
+  auto num_threads = arch_.num_threads();
+
+  uint32_t thread_start = 0;
+  for (; thread_start < num_threads; ++thread_start) {
+      if (warp.tmask.test(thread_start))
+        break;
+  }
+
+  std::vector<reg_data_t[3]> rsdata(num_threads);
+  std::vector<reg_data_t> rddata(num_threads);
+
+  auto num_rsrcs = instr.getNRSrc();
+  if (num_rsrcs) {
+    for (uint32_t i = 0; i < num_rsrcs; ++i) {
+      auto type = instr.getRSType(i);
+      auto reg = instr.getRSrc(i);
+      switch (type) {
+      case RegType::Integer:
+        DPH(2, "Src" << std::dec << i << " Reg: " << type << std::dec << reg << "={");
+        for (uint32_t t = 0; t < num_threads; ++t) {
+          if (t) DPN(2, ", ");
+          if (!warp.tmask.test(t)) {
+            DPN(2, "-");
+            continue;
+          }
+          rsdata[t][i].u = warp.ireg_file.at(t)[reg];
+          DPN(2, "0x" << std::hex << rsdata[t][i].i);
+        }
+        DPN(2, "}" << std::endl);
+        break;
+      case RegType::Float:
+        DPH(2, "Src" << std::dec << i << " Reg: " << type << std::dec << reg << "={");
+        for (uint32_t t = 0; t < num_threads; ++t) {
+          if (t) DPN(2, ", ");
+          if (!warp.tmask.test(t)) {
+            DPN(2, "-");
+            continue;
+          }
+          rsdata[t][i].u64 = warp.freg_file.at(t)[reg];
+          DPN(2, "0x" << std::hex << rsdata[t][i].f);
+        }
+        DPN(2, "}" << std::endl);
+        break;
+      case RegType::None:
+        break;
+      }
+    }
+  }
+
+  bool rd_write = false;
+
+  switch (opcode) {
+  case Opcode::LUI: {
+    // RV32I: LUI
+    trace->fu_type = FUType::ALU;
+    trace->alu_type = AluType::ARITH;
+    for (uint32_t t = thread_start; t < num_threads; ++t) {
+      if (!warp.tmask.test(t))
+        continue;
+      rddata[t].i = immsrc;
+    }
+    rd_write = true;
+    break;
+  }
+  case Opcode::AUIPC: {
+    // RV32I: AUIPC
+    trace->fu_type = FUType::ALU;
+    trace->alu_type = AluType::ARITH;
+    for (uint32_t t = thread_start; t < num_threads; ++t) {
+      if (!warp.tmask.test(t))
+        continue;
+      rddata[t].i = immsrc + warp.PC;
+    }
+    rd_write = true;
+    break;
+  }
+  case Opcode::R: {
+    trace->fu_type = FUType::ALU;
+    trace->alu_type = AluType::ARITH;
+    trace->used_iregs.set(rsrc0);
+    trace->used_iregs.set(rsrc1);
+    for (uint32_t t = thread_start; t < num_threads; ++t) {
+      if (!warp.tmask.test(t))
+        continue;
+      if (func7 & 0x1) {
+        switch (func3) {
+        case 0: {
+          // RV32M: MUL
+          rddata[t].i = rsdata[t][0].i * rsdata[t][1].i;
+          trace->alu_type = AluType::IMUL;
+          break;
+        }
+        case 1: {
+          // RV32M: MULH
+          auto first = static_cast<DWordI>(rsdata[t][0].i);
+          auto second = static_cast<DWordI>(rsdata[t][1].i);
+          rddata[t].i = (first * second) >> XLEN;
+          trace->alu_type = AluType::IMUL;
+          break;
+        }
+        case 2: {
+          // RV32M: MULHSU
+          auto first = static_cast<DWordI>(rsdata[t][0].i);
+          auto second = static_cast<DWord>(rsdata[t][1].u);
+          rddata[t].i = (first * second) >> XLEN;
+          trace->alu_type = AluType::IMUL;
+          break;
+        }
+        case 3: {
+          // RV32M: MULHU
+          auto first = static_cast<DWord>(rsdata[t][0].u);
+          auto second = static_cast<DWord>(rsdata[t][1].u);
+          rddata[t].i = (first * second) >> XLEN;
+          trace->alu_type = AluType::IMUL;
+          break;
+        }
+        case 4: {
+          // RV32M: DIV
+          auto dividen = rsdata[t][0].i;
+          auto divisor = rsdata[t][1].i;
+          auto largest_negative = WordI(1) << (XLEN-1);
+          if (divisor == 0) {
+            rddata[t].i = -1;
+          } else if (dividen == largest_negative && divisor == -1) {
+            rddata[t].i = dividen;
+          } else {
+            rddata[t].i = dividen / divisor;
+          }
+          trace->alu_type = AluType::IDIV;
+          break;
+        }
+        case 5: {
+          // RV32M: DIVU
+          auto dividen = rsdata[t][0].u;
+          auto divisor = rsdata[t][1].u;
+          if (divisor == 0) {
+            rddata[t].i = -1;
+          } else {
+            rddata[t].i = dividen / divisor;
+          }
+          trace->alu_type = AluType::IDIV;
+          break;
+        }
+        case 6: {
+          // RV32M: REM
+          auto dividen = rsdata[t][0].i;
+          auto divisor = rsdata[t][1].i;
+          auto largest_negative = WordI(1) << (XLEN-1);
+          if (rsdata[t][1].i == 0) {
+            rddata[t].i = dividen;
+          } else if (dividen == largest_negative && divisor == -1) {
+            rddata[t].i = 0;
+          } else {
+            rddata[t].i = dividen % divisor;
+          }
+          trace->alu_type = AluType::IDIV;
+          break;
+        }
+        case 7: {
+          // RV32M: REMU
+          auto dividen = rsdata[t][0].u;
+          auto divisor = rsdata[t][1].u;
+          if (rsdata[t][1].i == 0) {
+            rddata[t].i = dividen;
+          } else {
+            rddata[t].i = dividen % divisor;
+          }
+          trace->alu_type = AluType::IDIV;
+          break;
+        }
+        default:
+          std::abort();
+        }
+      } else {
+        switch (func3) {
+        case 0: {
+          if (func7 & 0x20) {
+            // RV32I: SUB
+            rddata[t].i = rsdata[t][0].i - rsdata[t][1].i;
+          } else {
+            // RV32I: ADD
+            rddata[t].i = rsdata[t][0].i + rsdata[t][1].i;
+          }
+          break;
+        }
+        case 1: {
+          // RV32I: SLL
+          Word shamt_mask = (Word(1) << log2up(XLEN)) - 1;
+          Word shamt = rsdata[t][1].i & shamt_mask;
+          rddata[t].i = rsdata[t][0].i << shamt;
+          break;
+        }
+        case 2: {
+          // RV32I: SLT
+          rddata[t].i = rsdata[t][0].i < rsdata[t][1].i;
+          break;
+        }
+        case 3: {
+          // RV32I: SLTU
+          rddata[t].i = rsdata[t][0].u < rsdata[t][1].u;
+          break;
+        }
+        case 4: {
+          // RV32I: XOR
+          rddata[t].i = rsdata[t][0].i ^ rsdata[t][1].i;
+          break;
+        }
+        case 5: {
+          Word shamt_mask = ((Word)1 << log2up(XLEN)) - 1;
+          Word shamt = rsdata[t][1].i & shamt_mask;
+          if (func7 & 0x20) {
+            // RV32I: SRA
+            rddata[t].i = rsdata[t][0].i >> shamt;
+          } else {
+            // RV32I: SRL
+            rddata[t].i = rsdata[t][0].u >> shamt;
+          }
+          break;
+        }
+        case 6: {
+          // RV32I: OR
+          rddata[t].i = rsdata[t][0].i | rsdata[t][1].i;
+          break;
+        }
+        case 7: {
+          // RV32I: AND
+          rddata[t].i = rsdata[t][0].i & rsdata[t][1].i;
+          break;
+        }
+        default:
+          std::abort();
+        }
+      }
+    }
+    rd_write = true;
+    break;
+  }
+  case Opcode::I: {
+    trace->fu_type = FUType::ALU;
+    trace->alu_type = AluType::ARITH;
+    trace->used_iregs.set(rsrc0);
+    for (uint32_t t = thread_start; t < num_threads; ++t) {
+      if (!warp.tmask.test(t))
+        continue;
+      switch (func3) {
+      case 0: {
+        // RV32I: ADDI
+        rddata[t].i = rsdata[t][0].i + immsrc;
+        break;
+      }
+      case 1: {
+        // RV32I: SLLI
+        rddata[t].i = rsdata[t][0].i << immsrc;
+        break;
+      }
+      case 2: {
+        // RV32I: SLTI
+        rddata[t].i = rsdata[t][0].i < WordI(immsrc);
+        break;
+      }
+      case 3: {
+        // RV32I: SLTIU
+        rddata[t].i = rsdata[t][0].u < immsrc;
+        break;
+      }
+      case 4: {
+        // RV32I: XORI
+        rddata[t].i = rsdata[t][0].i ^ immsrc;
+        break;
+      }
+      case 5: {
+        if (func7 & 0x20) {
+          // RV32I: SRAI
+          Word result = rsdata[t][0].i >> immsrc;
+          rddata[t].i = result;
+        } else {
+          // RV32I: SRLI
+          Word result = rsdata[t][0].u >> immsrc;
+          rddata[t].i = result;
+        }
+        break;
+      }
+      case 6: {
+        // RV32I: ORI
+        rddata[t].i = rsdata[t][0].i | immsrc;
+        break;
+      }
+      case 7: {
+        // RV32I: ANDI
+        rddata[t].i = rsdata[t][0].i & immsrc;
+        break;
+      }
+      }
+    }
+    rd_write = true;
+    break;
+  }
+  case Opcode::R_W: {
+    trace->fu_type = FUType::ALU;
+    trace->alu_type = AluType::ARITH;
+    trace->used_iregs.set(rsrc0);
+    trace->used_iregs.set(rsrc1);
+    for (uint32_t t = thread_start; t < num_threads; ++t) {
+      if (!warp.tmask.test(t))
+        continue;
+      if (func7 & 0x1) {
+        switch (func3) {
+          case 0: {
+            // RV64M: MULW
+            int32_t product = (int32_t)rsdata[t][0].i * (int32_t)rsdata[t][1].i;
+            rddata[t].i = sext((uint64_t)product, 32);
+            trace->alu_type = AluType::IMUL;
+            break;
+          }
+          case 4: {
+            // RV64M: DIVW
+            int32_t dividen = (int32_t)rsdata[t][0].i;
+            int32_t divisor = (int32_t)rsdata[t][1].i;
+            int32_t quotient;
+            int32_t largest_negative = 0x80000000;
+            if (divisor == 0){
+              quotient = -1;
+            } else if (dividen == largest_negative && divisor == -1) {
+              quotient = dividen;
+            } else {
+              quotient = dividen / divisor;
+            }
+            rddata[t].i = sext((uint64_t)quotient, 32);
+            trace->alu_type = AluType::IDIV;
+            break;
+          }
+          case 5: {
+            // RV64M: DIVUW
+            uint32_t dividen = (uint32_t)rsdata[t][0].i;
+            uint32_t divisor = (uint32_t)rsdata[t][1].i;
+            uint32_t quotient;
+            if (divisor == 0){
+              quotient = -1;
+            } else {
+              quotient = dividen / divisor;
+            }
+            rddata[t].i = sext((uint64_t)quotient, 32);
+            trace->alu_type = AluType::IDIV;
+            break;
+          }
+          case 6: {
+            // RV64M: REMW
+            int32_t dividen = (uint32_t)rsdata[t][0].i;
+            int32_t divisor = (uint32_t)rsdata[t][1].i;
+            int32_t remainder;
+            int32_t largest_negative = 0x80000000;
+            if (divisor == 0){
+              remainder = dividen;
+            } else if (dividen == largest_negative && divisor == -1) {
+              remainder = 0;
+            } else {
+              remainder = dividen % divisor;
+            }
+            rddata[t].i = sext((uint64_t)remainder, 32);
+            trace->alu_type = AluType::IDIV;
+            break;
+          }
+          case 7: {
+            // RV64M: REMUW
+            uint32_t dividen = (uint32_t)rsdata[t][0].i;
+            uint32_t divisor = (uint32_t)rsdata[t][1].i;
+            uint32_t remainder;
+            if (divisor == 0){
+              remainder = dividen;
+            } else {
+              remainder = dividen % divisor;
+            }
+            rddata[t].i = sext((uint64_t)remainder, 32);
+            trace->alu_type = AluType::IDIV;
+            break;
+          }
+          default:
+            std::abort();
+        }
+      } else {
+        switch (func3) {
+        case 0: {
+          if (func7 & 0x20){
+            // RV64I: SUBW
+            uint32_t result = (uint32_t)rsdata[t][0].i - (uint32_t)rsdata[t][1].i;
+            rddata[t].i = sext((uint64_t)result, 32);
+          }
+          else{
+            // RV64I: ADDW
+            uint32_t result = (uint32_t)rsdata[t][0].i + (uint32_t)rsdata[t][1].i;
+            rddata[t].i = sext((uint64_t)result, 32);
+          }
+          break;
+        }
+        case 1: {
+          // RV64I: SLLW
+          uint32_t shamt_mask = 0x1F;
+          uint32_t shamt = rsdata[t][1].i & shamt_mask;
+          uint32_t result = (uint32_t)rsdata[t][0].i << shamt;
+          rddata[t].i = sext((uint64_t)result, 32);
+          break;
+        }
+        case 5: {
+          uint32_t shamt_mask = 0x1F;
+          uint32_t shamt = rsdata[t][1].i & shamt_mask;
+          uint32_t result;
+          if (func7 & 0x20) {
+            // RV64I: SRAW
+            result = (int32_t)rsdata[t][0].i >> shamt;
+          } else {
+            // RV64I: SRLW
+            result = (uint32_t)rsdata[t][0].i >> shamt;
+          }
+          rddata[t].i = sext((uint64_t)result, 32);
+          break;
+        }
+        default:
+          std::abort();
+        }
+      }
+    }
+    rd_write = true;
+    break;
+  }
+  case Opcode::I_W: {
+    trace->fu_type = FUType::ALU;
+    trace->alu_type = AluType::ARITH;
+    trace->used_iregs.set(rsrc0);
+    for (uint32_t t = thread_start; t < num_threads; ++t) {
+      if (!warp.tmask.test(t))
+        continue;
+      switch (func3) {
+        case 0: {
+          // RV64I: ADDIW
+          uint32_t result = (uint32_t)rsdata[t][0].i + (uint32_t)immsrc;
+          rddata[t].i = sext((uint64_t)result, 32);
+          break;
+        }
+        case 1: {
+          // RV64I: SLLIW
+          uint32_t shamt_mask = 0x1F;
+          uint32_t shamt = immsrc & shamt_mask;
+          uint32_t result = rsdata[t][0].i << shamt;
+          rddata[t].i = sext((uint64_t)result, 32);
+          break;
+        }
+        case 5: {
+          uint32_t shamt_mask = 0x1F;
+          uint32_t shamt = immsrc & shamt_mask;
+          uint32_t result;
+          if (func7 & 0x20) {
+            // RV64I: SRAIW
+            result = (int32_t)rsdata[t][0].i >> shamt;
+          } else {
+            // RV64I: SRLIW
+            result = (uint32_t)rsdata[t][0].i >> shamt;
+          }
+          rddata[t].i = sext((uint64_t)result, 32);
+          break;
+        }
+        default:
+          std::abort();
+      }
+    }
+    rd_write = true;
+    break;
+  }
+  case Opcode::B: {
+    trace->fu_type = FUType::ALU;
+    trace->alu_type = AluType::BRANCH;
+    trace->used_iregs.set(rsrc0);
+    trace->used_iregs.set(rsrc1);
+    bool all_taken = false;
+    for (uint32_t t = thread_start; t < num_threads; ++t) {
+      if (!warp.tmask.test(t))
+        continue;
+      bool curr_taken = false;
+      switch (func3) {
+      case 0: {
+        // RV32I: BEQ
+        if (rsdata[t][0].i == rsdata[t][1].i) {
+          next_pc = warp.PC + immsrc;
+          curr_taken = true;
+        }
+        break;
+      }
+      case 1: {
+        // RV32I: BNE
+        if (rsdata[t][0].i != rsdata[t][1].i) {
+          next_pc = warp.PC + immsrc;
+          curr_taken = true;
+        }
+        break;
+      }
+      case 4: {
+        // RV32I: BLT
+        if (rsdata[t][0].i < rsdata[t][1].i) {
+          next_pc = warp.PC + immsrc;
+          curr_taken = true;
+        }
+        break;
+      }
+      case 5: {
+        // RV32I: BGE
+        if (rsdata[t][0].i >= rsdata[t][1].i) {
+          next_pc = warp.PC + immsrc;
+          curr_taken = true;
+        }
+        break;
+      }
+      case 6: {
+        // RV32I: BLTU
+        if (rsdata[t][0].u < rsdata[t][1].u) {
+          next_pc = warp.PC + immsrc;
+          curr_taken = true;
+        }
+        break;
+      }
+      case 7: {
+        // RV32I: BGEU
+        if (rsdata[t][0].u >= rsdata[t][1].u) {
+          next_pc = warp.PC + immsrc;
+          curr_taken = true;
+        }
+        break;
+      }
+      default:
+        std::abort();
+      }
+      if (t == thread_start) {
+        all_taken = curr_taken;
+      } else {
+        if (all_taken != curr_taken) {
+          std::cout << "divergent branch! PC=0x" << std::hex << warp.PC << " (#" << std::dec << trace->uuid << ")\n" << std::flush;
+          std::abort();
+        }
+      }
+    }
+    trace->fetch_stall = true;
+    break;
+  }
+  case Opcode::JAL: {
+    // RV32I: JAL
+    trace->fu_type = FUType::ALU;
+    trace->alu_type = AluType::BRANCH;
+    for (uint32_t t = thread_start; t < num_threads; ++t) {
+      if (!warp.tmask.test(t))
+        continue;
+      rddata[t].i = next_pc;
+    }
+    next_pc = warp.PC + immsrc;
+    trace->fetch_stall = true;
+    rd_write = true;
+    break;
+  }
+  case Opcode::JALR: {
+    // RV32I: JALR
+    trace->fu_type = FUType::ALU;
+    trace->alu_type = AluType::BRANCH;
+    trace->used_iregs.set(rsrc0);
+    for (uint32_t t = thread_start; t < num_threads; ++t) {
+      if (!warp.tmask.test(t))
+        continue;
+      rddata[t].i = next_pc;
+    }
+    next_pc = rsdata[thread_start][0].i + immsrc;
+    trace->fetch_stall = true;
+    rd_write = true;
+    break;
+  }
+  case Opcode::L:
+  case Opcode::FL: {
+    trace->fu_type = FUType::LSU;
+    trace->lsu_type = LsuType::LOAD;
+    trace->used_iregs.set(rsrc0);
+    auto trace_data = std::make_shared<LsuTraceData>(num_threads);
+    trace->data = trace_data;
+    uint32_t data_bytes = 1 << (func3 & 0x3);
+    uint32_t data_width = 8 * data_bytes;
+    for (uint32_t t = thread_start; t < num_threads; ++t) {
+      if (!warp.tmask.test(t))
+        continue;
+      uint64_t mem_addr = rsdata[t][0].i + immsrc;
+      uint64_t read_data = 0;
+      this->dcache_read(&read_data, mem_addr, data_bytes);
+      trace_data->mem_addrs.at(t) = {mem_addr, data_bytes};
+      switch (func3) {
+      case 0: // RV32I: LB
+      case 1: // RV32I: LH
+        rddata[t].i = sext((Word)read_data, data_width);
+        break;
+      case 2:
+        if (opcode == Opcode::L) {
+          // RV32I: LW
+          rddata[t].i = sext((Word)read_data, data_width);
+        } else {
+          // RV32F: FLW
+          rddata[t].u64 = nan_box((uint32_t)read_data);
+        }
+        break;
+      case 3: // RV64I: LD
+              // RV32D: FLD
+      case 4: // RV32I: LBU
+      case 5: // RV32I: LHU
+      case 6: // RV64I: LWU
+        rddata[t].u64 = read_data;
+        break;
+      default:
+        std::abort();
+      }
+    }
+    rd_write = true;
+    break;
+  }
+  case Opcode::S:
+  case Opcode::FS: {
+    trace->fu_type = FUType::LSU;
+    trace->lsu_type = LsuType::STORE;
+    trace->used_iregs.set(rsrc0);
+    trace->used_iregs.set(rsrc1);
+    auto trace_data = std::make_shared<LsuTraceData>(num_threads);
+    trace->data = trace_data;
+    uint32_t data_bytes = 1 << (func3 & 0x3);
+    for (uint32_t t = thread_start; t < num_threads; ++t) {
+      if (!warp.tmask.test(t))
+        continue;
+      uint64_t mem_addr = rsdata[t][0].i + immsrc;
+      uint64_t write_data = rsdata[t][1].u64;
+      trace_data->mem_addrs.at(t) = {mem_addr, data_bytes};
+      switch (func3) {
+      case 0:
+      case 1:
+      case 2:
+      case 3:
+        this->dcache_write(&write_data, mem_addr, data_bytes);
+        break;
+      default:
+        std::abort();
+      }
+    }
+    break;
+  }
+  case Opcode::AMO: {
+    trace->fu_type = FUType::LSU;
+    trace->lsu_type = LsuType::LOAD;
+    trace->used_iregs.set(rsrc0);
+    trace->used_iregs.set(rsrc1);
+    auto trace_data = std::make_shared<LsuTraceData>(num_threads);
+    trace->data = trace_data;
+    auto amo_type = func7 >> 2;
+    uint32_t data_bytes = 1 << (func3 & 0x3);
+    uint32_t data_width = 8 * data_bytes;
+    for (uint32_t t = thread_start; t < num_threads; ++t) {
+      if (!warp.tmask.test(t))
+        continue;
+      uint64_t mem_addr = rsdata[t][0].u;
+      trace_data->mem_addrs.at(t) = {mem_addr, data_bytes};
+      if (amo_type == 0x02) { // LR
+        uint64_t read_data = 0;
+        this->dcache_read(&read_data, mem_addr, data_bytes);
+        this->dcache_amo_reserve(mem_addr);
+        rddata[t].i = sext((Word)read_data, data_width);
+      } else
+      if (amo_type == 0x03) { // SC
+        if (this->dcache_amo_check(mem_addr)) {
+          this->dcache_write(&rsdata[t][1].u64, mem_addr, data_bytes);
+          rddata[t].i = 0;
+        } else {
+          rddata[t].i = 1;
+        }
+      } else {
+        uint64_t read_data = 0;
+        this->dcache_read(&read_data, mem_addr, data_bytes);
+        auto read_data_i = sext((WordI)read_data, data_width);
+        auto rs1_data_i  = sext((WordI)rsdata[t][1].u64, data_width);
+        auto read_data_u = zext((Word)read_data, data_width);
+        auto rs1_data_u  = zext((Word)rsdata[t][1].u64, data_width);
+        uint64_t result;
+        switch (amo_type) {
+        case 0x00:  // AMOADD
+          result = read_data_i + rs1_data_i;
+          break;
+        case 0x01:  // AMOSWAP
+          result = rs1_data_u;
+          break;
+        case 0x04:  // AMOXOR
+          result = read_data_u ^ rs1_data_u;
+          break;
+        case 0x08:  // AMOOR
+          result = read_data_u | rs1_data_u;
+          break;
+        case 0x0c:  // AMOAND
+          result = read_data_u & rs1_data_u;
+          break;
+        case 0x10:  // AMOMIN
+          result = std::min(read_data_i, rs1_data_i);
+          break;
+        case 0x14:  // AMOMAX
+          result = std::max(read_data_i, rs1_data_i);
+          break;
+        case 0x18:  // AMOMINU
+          result = std::min(read_data_u, rs1_data_u);
+          break;
+        case 0x1c:  // AMOMAXU
+          result = std::max(read_data_u, rs1_data_u);
+          break;
+        default:
+          std::abort();
+        }
+        this->dcache_write(&result, mem_addr, data_bytes);
+        rddata[t].i = read_data_i;
+      }
+    }
+    rd_write = true;
+    break;
+  }
+  case Opcode::SYS: {
+    for (uint32_t t = thread_start; t < num_threads; ++t) {
+      if (!warp.tmask.test(t))
+        continue;
+      uint32_t csr_addr = immsrc;
+      Word csr_value;
+      if (func3 == 0) {
+        trace->fu_type = FUType::ALU;
+        trace->alu_type = AluType::SYSCALL;
+        trace->fetch_stall = true;
+        switch (csr_addr) {
+        case 0:
+          // RV32I: ECALL
+          this->trigger_ecall();
+          break;
+        case 1:
+          // RV32I: EBREAK
+          this->trigger_ebreak();
+          break;
+        case 0x002: // URET
+        case 0x102: // SRET
+        case 0x302: // MRET
+          break;
+        default:
+          std::abort();
+        }
+      } else {
+        trace->fu_type = FUType::SFU;
+        trace->fetch_stall = true;
+        csr_value = this->get_csr(csr_addr, t, wid);
+        switch (func3) {
+        case 1: {
+          // RV32I: CSRRW
+          rddata[t].i = csr_value;
+          this->set_csr(csr_addr, rsdata[t][0].i, t, wid);
+          trace->used_iregs.set(rsrc0);
+          trace->sfu_type = SfuType::CSRRW;
+          rd_write = true;
+          break;
+        }
+        case 2: {
+          // RV32I: CSRRS
+          rddata[t].i = csr_value;
+          if (rsdata[t][0].i != 0) {
+            this->set_csr(csr_addr, csr_value | rsdata[t][0].i, t, wid);
+          }
+          trace->used_iregs.set(rsrc0);
+          trace->sfu_type = SfuType::CSRRS;
+          rd_write = true;
+          break;
+        }
+        case 3: {
+          // RV32I: CSRRC
+          rddata[t].i = csr_value;
+          if (rsdata[t][0].i != 0) {
+            this->set_csr(csr_addr, csr_value & ~rsdata[t][0].i, t, wid);
+          }
+          trace->used_iregs.set(rsrc0);
+          trace->sfu_type = SfuType::CSRRC;
+          rd_write = true;
+          break;
+        }
+        case 5: {
+          // RV32I: CSRRWI
+          rddata[t].i = csr_value;
+          this->set_csr(csr_addr, rsrc0, t, wid);
+          trace->sfu_type = SfuType::CSRRW;
+          rd_write = true;
+          break;
+        }
+        case 6: {
+          // RV32I: CSRRSI;
+          rddata[t].i = csr_value;
+          if (rsrc0 != 0) {
+            this->set_csr(csr_addr, csr_value | rsrc0, t, wid);
+          }
+          trace->sfu_type = SfuType::CSRRS;
+          rd_write = true;
+          break;
+        }
+        case 7: {
+          // RV32I: CSRRCI
+          rddata[t].i = csr_value;
+          if (rsrc0 != 0) {
+            this->set_csr(csr_addr, csr_value & ~rsrc0, t, wid);
+          }
+          trace->sfu_type = SfuType::CSRRC;
+          rd_write = true;
+          break;
+        }
+        default:
+          break;
+        }
+      }
+    }
+    break;
+  }
+  case Opcode::FENCE: {
+    // RV32I: FENCE
+    trace->fu_type = FUType::LSU;
+    trace->lsu_type = LsuType::FENCE;
+    break;
+  }
+  case Opcode::FCI: {
+    trace->fu_type = FUType::FPU;
+    for (uint32_t t = thread_start; t < num_threads; ++t) {
+      if (!warp.tmask.test(t))
+        continue;
+      uint32_t frm = this->get_fpu_rm(func3, t, wid);
+      uint32_t fflags = 0;
+      switch (func7) {
+      case 0x00: { // RV32F: FADD.S
+        rddata[t].u64 = nan_box(rv_fadd_s(check_boxing(rsdata[t][0].u64), check_boxing(rsdata[t][1].u64), frm, &fflags));
+        trace->fpu_type = FpuType::FMA;
+        trace->used_fregs.set(rsrc0);
+        trace->used_fregs.set(rsrc1);
+        break;
+      }
+      case 0x01: { // RV32D: FADD.D
+        rddata[t].u64 = rv_fadd_d(rsdata[t][0].u64, rsdata[t][1].u64, frm, &fflags);
+        trace->fpu_type = FpuType::FMA;
+        trace->used_fregs.set(rsrc0);
+        trace->used_fregs.set(rsrc1);
+        break;
+      }
+      case 0x04: { // RV32F: FSUB.S
+        rddata[t].u64 = nan_box(rv_fsub_s(check_boxing(rsdata[t][0].u64), check_boxing(rsdata[t][1].u64), frm, &fflags));
+        trace->fpu_type = FpuType::FMA;
+        trace->used_fregs.set(rsrc0);
+        trace->used_fregs.set(rsrc1);
+        break;
+      }
+      case 0x05: { // RV32D: FSUB.D
+        rddata[t].u64 = rv_fsub_d(rsdata[t][0].u64, rsdata[t][1].u64, frm, &fflags);
+        trace->fpu_type = FpuType::FMA;
+        trace->used_fregs.set(rsrc0);
+        trace->used_fregs.set(rsrc1);
+        break;
+      }
+      case 0x08: { // RV32F: FMUL.S
+        rddata[t].u64 = nan_box(rv_fmul_s(check_boxing(rsdata[t][0].u64), check_boxing(rsdata[t][1].u64), frm, &fflags));
+        trace->fpu_type = FpuType::FMA;
+        trace->used_fregs.set(rsrc0);
+        trace->used_fregs.set(rsrc1);
+        break;
+      }
+      case 0x09: { // RV32D: FMUL.D
+        rddata[t].u64 = rv_fmul_d(rsdata[t][0].u64, rsdata[t][1].u64, frm, &fflags);
+        trace->fpu_type = FpuType::FMA;
+        trace->used_fregs.set(rsrc0);
+        trace->used_fregs.set(rsrc1);
+        break;
+      }
+      case 0x0c: { // RV32F: FDIV.S
+        rddata[t].u64 = nan_box(rv_fdiv_s(check_boxing(rsdata[t][0].u64), check_boxing(rsdata[t][1].u64), frm, &fflags));
+        trace->fpu_type = FpuType::FDIV;
+        trace->used_fregs.set(rsrc0);
+        trace->used_fregs.set(rsrc1);
+        break;
+      }
+      case 0x0d: { // RV32D: FDIV.D
+        rddata[t].u64 = rv_fdiv_d(rsdata[t][0].u64, rsdata[t][1].u64, frm, &fflags);
+        trace->fpu_type = FpuType::FDIV;
+        trace->used_fregs.set(rsrc0);
+        trace->used_fregs.set(rsrc1);
+        break;
+      }
+      case 0x10: {
+        switch (func3) {
+        case 0: // RV32F: FSGNJ.S
+          rddata[t].u64 = nan_box(rv_fsgnj_s(check_boxing(rsdata[t][0].u64), check_boxing(rsdata[t][1].u64)));
+          break;
+        case 1: // RV32F: FSGNJN.S
+          rddata[t].u64 = nan_box(rv_fsgnjn_s(check_boxing(rsdata[t][0].u64), check_boxing(rsdata[t][1].u64)));
+          break;
+        case 2: // RV32F: FSGNJX.S
+          rddata[t].u64 = nan_box(rv_fsgnjx_s(check_boxing(rsdata[t][0].u64), check_boxing(rsdata[t][1].u64)));
+          break;
+        }
+        trace->fpu_type = FpuType::FNCP;
+        trace->used_fregs.set(rsrc0);
+        trace->used_fregs.set(rsrc1);
+        break;
+      }
+      case 0x11: {
+        switch (func3) {
+        case 0: // RV32D: FSGNJ.D
+          rddata[t].u64 = rv_fsgnj_d(rsdata[t][0].u64, rsdata[t][1].u64);
+          break;
+        case 1: // RV32D: FSGNJN.D
+          rddata[t].u64 = rv_fsgnjn_d(rsdata[t][0].u64, rsdata[t][1].u64);
+          break;
+        case 2: // RV32D: FSGNJX.D
+          rddata[t].u64 = rv_fsgnjx_d(rsdata[t][0].u64, rsdata[t][1].u64);
+          break;
+        }
+        trace->fpu_type = FpuType::FNCP;
+        trace->used_fregs.set(rsrc0);
+        trace->used_fregs.set(rsrc1);
+        break;
+      }
+      case 0x14: {
+        if (func3) {
+          // RV32F: FMAX.S
+          rddata[t].u64 = nan_box(rv_fmax_s(check_boxing(rsdata[t][0].u64), check_boxing(rsdata[t][1].u64), &fflags));
+        } else {
+          // RV32F: FMIN.S
+          rddata[t].u64 = nan_box(rv_fmin_s(check_boxing(rsdata[t][0].u64), check_boxing(rsdata[t][1].u64), &fflags));
+        }
+        trace->fpu_type = FpuType::FNCP;
+        trace->used_fregs.set(rsrc0);
+        trace->used_fregs.set(rsrc1);
+        break;
+      }
+      case 0x15: {
+        if (func3) {
+          // RV32D: FMAX.D
+          rddata[t].u64 = rv_fmax_d(rsdata[t][0].u64, rsdata[t][1].u64, &fflags);
+        } else {
+          // RV32D: FMIN.D
+          rddata[t].u64 = rv_fmin_d(rsdata[t][0].u64, rsdata[t][1].u64, &fflags);
+        }
+        trace->fpu_type = FpuType::FNCP;
+        trace->used_fregs.set(rsrc0);
+        trace->used_fregs.set(rsrc1);
+        break;
+      }
+      case 0x20: {
+        // RV32D: FCVT.S.D
+        rddata[t].u64 = nan_box(rv_dtof(rsdata[t][0].u64));
+        trace->fpu_type = FpuType::FNCP;
+        trace->used_fregs.set(rsrc0);
+        break;
+      }
+      case 0x21: {
+        // RV32D: FCVT.D.S
+        rddata[t].u64 = rv_ftod(check_boxing(rsdata[t][0].u64));
+        trace->fpu_type = FpuType::FNCP;
+        trace->used_fregs.set(rsrc0);
+        break;
+      }
+      case 0x2c: { // RV32F: FSQRT.S
+        rddata[t].u64 = nan_box(rv_fsqrt_s(check_boxing(rsdata[t][0].u64), frm, &fflags));
+        trace->fpu_type = FpuType::FSQRT;
+        trace->used_fregs.set(rsrc0);
+        break;
+      }
+      case 0x2d: { // RV32D: FSQRT.D
+        rddata[t].u64 = rv_fsqrt_d(rsdata[t][0].u64, frm, &fflags);
+        trace->fpu_type = FpuType::FSQRT;
+        trace->used_fregs.set(rsrc0);
+        break;
+      }
+      case 0x50: {
+        switch (func3) {
+        case 0:
+          // RV32F: FLE.S
+          rddata[t].i = rv_fle_s(check_boxing(rsdata[t][0].u64), check_boxing(rsdata[t][1].u64), &fflags);
+          break;
+        case 1:
+          // RV32F: FLT.S
+          rddata[t].i = rv_flt_s(check_boxing(rsdata[t][0].u64), check_boxing(rsdata[t][1].u64), &fflags);
+          break;
+        case 2:
+          // RV32F: FEQ.S
+          rddata[t].i = rv_feq_s(check_boxing(rsdata[t][0].u64), check_boxing(rsdata[t][1].u64), &fflags);
+          break;
+        }
+        trace->fpu_type = FpuType::FNCP;
+        trace->used_fregs.set(rsrc0);
+        trace->used_fregs.set(rsrc1);
+        break;
+      }
+      case 0x51: {
+        switch (func3) {
+        case 0:
+          // RV32D: FLE.D
+          rddata[t].i = rv_fle_d(rsdata[t][0].u64, rsdata[t][1].u64, &fflags);
+          break;
+        case 1:
+          // RV32D: FLT.D
+          rddata[t].i = rv_flt_d(rsdata[t][0].u64, rsdata[t][1].u64, &fflags);
+          break;
+        case 2:
+          // RV32D: FEQ.D
+          rddata[t].i = rv_feq_d(rsdata[t][0].u64, rsdata[t][1].u64, &fflags);
+          break;
+        }
+        trace->fpu_type = FpuType::FNCP;
+        trace->used_fregs.set(rsrc0);
+        trace->used_fregs.set(rsrc1);
+        break;
+      }
+      case 0x60: {
+        switch (rsrc1) {
+        case 0:
+          // RV32F: FCVT.W.S
+          rddata[t].i = sext((uint64_t)rv_ftoi_s(check_boxing(rsdata[t][0].u64), frm, &fflags), 32);
+          break;
+        case 1:
+          // RV32F: FCVT.WU.S
+          rddata[t].i = sext((uint64_t)rv_ftou_s(check_boxing(rsdata[t][0].u64), frm, &fflags), 32);
+          break;
+        case 2:
+          // RV64F: FCVT.L.S
+          rddata[t].i = rv_ftol_s(check_boxing(rsdata[t][0].u64), frm, &fflags);
+          break;
+        case 3:
+          // RV64F: FCVT.LU.S
+          rddata[t].i = rv_ftolu_s(check_boxing(rsdata[t][0].u64), frm, &fflags);
+          break;
+        }
+        trace->fpu_type = FpuType::FCVT;
+        trace->used_fregs.set(rsrc0);
+        break;
+      }
+      case 0x61: {
+        switch (rsrc1) {
+        case 0:
+          // RV32D: FCVT.W.D
+          rddata[t].i = sext((uint64_t)rv_ftoi_d(rsdata[t][0].u64, frm, &fflags), 32);
+          break;
+        case 1:
+          // RV32D: FCVT.WU.D
+          rddata[t].i = sext((uint64_t)rv_ftou_d(rsdata[t][0].u64, frm, &fflags), 32);
+          break;
+        case 2:
+          // RV64D: FCVT.L.D
+          rddata[t].i = rv_ftol_d(rsdata[t][0].u64, frm, &fflags);
+          break;
+        case 3:
+          // RV64D: FCVT.LU.D
+          rddata[t].i = rv_ftolu_d(rsdata[t][0].u64, frm, &fflags);
+          break;
+        }
+        trace->fpu_type = FpuType::FCVT;
+        trace->used_fregs.set(rsrc0);
+        break;
+      }
+      case 0x68: {
+        switch (rsrc1) {
+        case 0:
+          // RV32F: FCVT.S.W
+          rddata[t].u64 = nan_box(rv_itof_s(rsdata[t][0].i, frm, &fflags));
+          break;
+        case 1:
+          // RV32F: FCVT.S.WU
+          rddata[t].u64 = nan_box(rv_utof_s(rsdata[t][0].i, frm, &fflags));
+          break;
+        case 2:
+          // RV64F: FCVT.S.L
+          rddata[t].u64 = nan_box(rv_ltof_s(rsdata[t][0].i, frm, &fflags));
+          break;
+        case 3:
+          // RV64F: FCVT.S.LU
+          rddata[t].u64 = nan_box(rv_lutof_s(rsdata[t][0].i, frm, &fflags));
+          break;
+        }
+        trace->fpu_type = FpuType::FCVT;
+        trace->used_iregs.set(rsrc0);
+        break;
+      }
+      case 0x69: {
+        switch (rsrc1) {
+        case 0:
+          // RV32D: FCVT.D.W
+          rddata[t].u64 = rv_itof_d(rsdata[t][0].i, frm, &fflags);
+          break;
+        case 1:
+          // RV32D: FCVT.D.WU
+          rddata[t].u64 = rv_utof_d(rsdata[t][0].i, frm, &fflags);
+          break;
+        case 2:
+          // RV64D: FCVT.D.L
+          rddata[t].u64 = rv_ltof_d(rsdata[t][0].i, frm, &fflags);
+          break;
+        case 3:
+          // RV64D: FCVT.D.LU
+          rddata[t].u64 = rv_lutof_d(rsdata[t][0].i, frm, &fflags);
+          break;
+        }
+        trace->fpu_type = FpuType::FCVT;
+        trace->used_iregs.set(rsrc0);
+        break;
+      }
+      case 0x70: {
+        if (func3) {
+          // RV32F: FCLASS.S
+          rddata[t].i = rv_fclss_s(check_boxing(rsdata[t][0].u64));
+        } else {
+          // RV32F: FMV.X.S
+          uint32_t result = (uint32_t)rsdata[t][0].u64;
+          rddata[t].i = sext((uint64_t)result, 32);
+        }
+        trace->fpu_type = FpuType::FNCP;
+        trace->used_fregs.set(rsrc0);
+        break;
+      }
+      case 0x71: {
+        if (func3) {
+          // RV32D: FCLASS.D
+          rddata[t].i = rv_fclss_d(rsdata[t][0].u64);
+        } else {
+          // RV64D: FMV.X.D
+          rddata[t].i = rsdata[t][0].u64;
+        }
+        trace->fpu_type = FpuType::FNCP;
+        trace->used_fregs.set(rsrc0);
+        break;
+      }
+      case 0x78: { // RV32F: FMV.S.X
+        rddata[t].u64 = nan_box((uint32_t)rsdata[t][0].i);
+        trace->fpu_type = FpuType::FNCP;
+        trace->used_iregs.set(rsrc0);
+        break;
+      }
+      case 0x79: { // RV64D: FMV.D.X
+        rddata[t].u64 = rsdata[t][0].i;
+        trace->fpu_type = FpuType::FNCP;
+        trace->used_iregs.set(rsrc0);
+        break;
+      }
+      }
+      this->update_fcrs(fflags, t, wid);
+    }
+    rd_write = true;
+    break;
+  }
+  case Opcode::FMADD:
+  case Opcode::FMSUB:
+  case Opcode::FMNMADD:
+  case Opcode::FMNMSUB: {
+    trace->fpu_type = FpuType::FMA;
+    trace->used_fregs.set(rsrc0);
+    trace->used_fregs.set(rsrc1);
+    trace->used_fregs.set(rsrc2);
+    for (uint32_t t = thread_start; t < num_threads; ++t) {
+      if (!warp.tmask.test(t))
+        continue;
+      uint32_t frm = this->get_fpu_rm(func3, t, wid);
+      uint32_t fflags = 0;
+      switch (opcode) {
+      case Opcode::FMADD:
+        if (func2)
+          // RV32D: FMADD.D
+          rddata[t].u64 = rv_fmadd_d(rsdata[t][0].u64, rsdata[t][1].u64, rsdata[t][2].u64, frm, &fflags);
+        else
+          // RV32F: FMADD.S
+          rddata[t].u64 = nan_box(rv_fmadd_s(check_boxing(rsdata[t][0].u64), check_boxing(rsdata[t][1].u64), check_boxing(rsdata[t][2].u64), frm, &fflags));
+        break;
+      case Opcode::FMSUB:
+        if (func2)
+          // RV32D: FMSUB.D
+          rddata[t].u64 = rv_fmsub_d(rsdata[t][0].u64, rsdata[t][1].u64, rsdata[t][2].u64, frm, &fflags);
+        else
+          // RV32F: FMSUB.S
+          rddata[t].u64 = nan_box(rv_fmsub_s(check_boxing(rsdata[t][0].u64), check_boxing(rsdata[t][1].u64), check_boxing(rsdata[t][2].u64), frm, &fflags));
+        break;
+      case Opcode::FMNMADD:
+        if (func2)
+          // RV32D: FNMADD.D
+          rddata[t].u64 = rv_fnmadd_d(rsdata[t][0].u64, rsdata[t][1].u64, rsdata[t][2].u64, frm, &fflags);
+        else
+          // RV32F: FNMADD.S
+          rddata[t].u64 = nan_box(rv_fnmadd_s(check_boxing(rsdata[t][0].u64), check_boxing(rsdata[t][1].u64), check_boxing(rsdata[t][2].u64), frm, &fflags));
+        break;
+      case Opcode::FMNMSUB:
+        if (func2)
+          // RV32D: FNMSUB.D
+          rddata[t].u64 = rv_fnmsub_d(rsdata[t][0].u64, rsdata[t][1].u64, rsdata[t][2].u64, frm, &fflags);
+        else
+          // RV32F: FNMSUB.S
+          rddata[t].u64 = nan_box(rv_fnmsub_s(check_boxing(rsdata[t][0].u64), check_boxing(rsdata[t][1].u64), check_boxing(rsdata[t][2].u64), frm, &fflags));
+        break;
+      default:
+        break;
+      }
+      this->update_fcrs(fflags, t, wid);
+    }
+    rd_write = true;
+    break;
+  }
+  case Opcode::EXT1: {
+    switch (func7) {
+    case 0: {
+      switch (func3) {
+      case 0: {
+        // TMC
+        trace->fu_type = FUType::SFU;
+        trace->sfu_type = SfuType::TMC;
+        trace->used_iregs.set(rsrc0);
+        trace->fetch_stall = true;
+        next_tmask.reset();
+        for (uint32_t t = 0; t < num_threads; ++t) {
+          next_tmask.set(t, rsdata.at(thread_start)[0].i & (1 << t));
+        }
+      } break;
+      case 1: {
+        // WSPAWN
+        trace->fu_type = FUType::SFU;
+        trace->sfu_type = SfuType::WSPAWN;
+        trace->used_iregs.set(rsrc0);
+        trace->used_iregs.set(rsrc1);
+        trace->fetch_stall = true;
+        trace->data = std::make_shared<SFUTraceData>(rsdata.at(thread_start)[0].i, rsdata.at(thread_start)[1].i);
+      } break;
+      case 2: {
+        // SPLIT
+        trace->fu_type = FUType::SFU;
+        trace->sfu_type = SfuType::SPLIT;
+        trace->used_iregs.set(rsrc0);
+        trace->fetch_stall = true;
+
+        auto stack_size = warp.ipdom_stack.size();
+
+        ThreadMask then_tmask, else_tmask;
+        auto not_pred = rsrc2 & 0x1;
+        for (uint32_t t = 0; t < num_threads; ++t) {
+          auto cond = (warp.ireg_file.at(t).at(rsrc0) & 0x1) ^ not_pred;
+          then_tmask[t] = warp.tmask.test(t) && cond;
+          else_tmask[t] = warp.tmask.test(t) && !cond;
+        }
+
+        bool is_divergent = then_tmask.any() && else_tmask.any();
+        if (is_divergent) {
+          if (stack_size == arch_.ipdom_size()) {
+            std::cout << "IPDOM stack is full! size=" << std::dec << stack_size << ", PC=0x" << std::hex << warp.PC << " (#" << std::dec << trace->uuid << ")\n" << std::flush;
+            std::abort();
+          }
+          // set new thread mask to the larger set
+          if (then_tmask.count() >= else_tmask.count()) {
+            next_tmask = then_tmask;
+          } else {
+            next_tmask = else_tmask;
+          }
+          // push reconvergence thread mask onto the stack
+          warp.ipdom_stack.emplace(warp.tmask);
+          // push not taken thread mask onto the stack
+          auto ntaken_tmask = ~next_tmask & warp.tmask;
+          warp.ipdom_stack.emplace(ntaken_tmask, next_pc);
+        }
+        // return divergent state
+        for (uint32_t t = thread_start; t < num_threads; ++t) {
+          rddata[t].i = stack_size;
+        }
+        rd_write = true;
+      } break;
+      case 3: {
+        // JOIN
+        trace->fu_type = FUType::SFU;
+        trace->sfu_type = SfuType::JOIN;
+        trace->used_iregs.set(rsrc0);
+        trace->fetch_stall = true;
+
+        auto stack_ptr = warp.ireg_file.at(thread_start).at(rsrc0);
+        if (stack_ptr != warp.ipdom_stack.size()) {
+          if (warp.ipdom_stack.empty()) {
+            std::cout << "IPDOM stack is empty!\n" << std::flush;
+            std::abort();
+          }
+          next_tmask = warp.ipdom_stack.top().tmask;
+          if (!warp.ipdom_stack.top().fallthrough) {
+            next_pc = warp.ipdom_stack.top().PC;
+          }
+          warp.ipdom_stack.pop();
+        }
+      } break;
+      case 4: {
+        // BAR
+        trace->fu_type = FUType::SFU;
+        trace->sfu_type = SfuType::BAR;
+        trace->used_iregs.set(rsrc0);
+        trace->used_iregs.set(rsrc1);
+        trace->fetch_stall = true;
+        trace->data = std::make_shared<SFUTraceData>(rsdata[thread_start][0].i, rsdata[thread_start][1].i);
+      } break;
+      case 5: {
+        // PRED
+        trace->fu_type = FUType::SFU;
+        trace->sfu_type = SfuType::PRED;
+        trace->used_iregs.set(rsrc0);
+        trace->used_iregs.set(rsrc1);
+        trace->fetch_stall = true;
+        ThreadMask pred;
+        auto not_pred = rdest & 0x1;
+        for (uint32_t t = 0; t < num_threads; ++t) {
+          auto cond = (warp.ireg_file.at(t).at(rsrc0) & 0x1) ^ not_pred;
+          pred[t] = warp.tmask.test(t) && cond;
+        }
+        if (pred.any()) {
+          next_tmask &= pred;
+        } else {
+          next_tmask = warp.ireg_file.at(thread_start).at(rsrc1);
+        }
+      } break;
+      default:
+        std::abort();
+      }
+    } break;
+    case 1:
+      switch (func3) {
+      case 0: { // DOT8
+        trace->fu_type = FUType::ALU;
+        trace->alu_type = AluType::DOT8;
+        trace->used_iregs.set(rsrc0);
+        trace->used_iregs.set(rsrc1);
+        for (uint32_t t = thread_start; t < num_threads; ++t) {
+          if (!warp.tmask.test(t))
+            continue;
+          uint32_t a = rsdata[t][0].i; // rs1
+          uint32_t b = rsdata[t][1].i; // rs2
+
+          // TODO:
+          // int c = ?
+
+          // rddata[t].i = c;
+
+          {
+            auto a0 = (a >> 0) & 0xff;
+            auto a1 = (a >> 8) & 0xff;
+            auto a2 = (a >> 16) & 0xff;
+            auto a3 = (a >> 24) & 0xff;
+            auto b0 = (b >> 0) & 0xff;
+            auto b1 = (b >> 8) & 0xff;
+            auto b2 = (b >> 16) & 0xff;
+            auto b3 = (b >> 24) & 0xff;
+            rddata[t].i = (a0 * b0) + (a1 * b1) + (a2 * b2) + (a3 * b3);
+          }
+        }
+        rd_write = true;
+      } break;
+      default:
+          std::abort();
+      }
+      break;
+    default:
+      std::abort();
+    }
+  } break;
+  case Opcode::EXT2: {
+    switch (func3) {
+    case 1:
+      switch (func2) {
+      case 0: { // CMOV
+        trace->fu_type = FUType::SFU;
+        trace->sfu_type = SfuType::CMOV;
+        trace->used_iregs.set(rsrc0);
+        trace->used_iregs.set(rsrc1);
+        trace->used_iregs.set(rsrc2);
+        for (uint32_t t = thread_start; t < num_threads; ++t) {
+          if (!warp.tmask.test(t))
+            continue;
+          rddata[t].i = rsdata[t][0].i ? rsdata[t][1].i : rsdata[t][2].i;
+        }
+        rd_write = true;
+      } break;
+      default:
+        std::abort();
+      }
+      break;
+    default:
+      std::abort();
+    }
+  } break;
+  default:
+    std::abort();
+  }
+
+  if (rd_write) {
+    trace->wb = true;
+    auto type = instr.getRDType();
+    switch (type) {
+    case RegType::Integer:
+      if (rdest) {
+        DPH(2, "Dest Reg: " << type << std::dec << rdest << "={");
+        for (uint32_t t = 0; t < num_threads; ++t) {
+          if (t) DPN(2, ", ");
+          if (!warp.tmask.test(t)) {
+            DPN(2, "-");
+            continue;
+          }
+          warp.ireg_file.at(t)[rdest] = rddata[t].i;
+          DPN(2, "0x" << std::hex << rddata[t].i);
+        }
+        DPN(2, "}" << std::endl);
+        trace->used_iregs[rdest] = 1;
+        assert(rdest != 0);
+      } else {
+        // disable writes to x0
+        trace->wb = false;
+      }
+      break;
+    case RegType::Float:
+      DPH(2, "Dest Reg: " << type << std::dec << rdest << "={");
+      for (uint32_t t = 0; t < num_threads; ++t) {
+        if (t) DPN(2, ", ");
+        if (!warp.tmask.test(t)) {
+          DPN(2, "-");
+          continue;
+        }
+        warp.freg_file.at(t)[rdest] = rddata[t].u64;
+        DPN(2, "0x" << std::hex << rddata[t].f);
+      }
+      DPN(2, "}" << std::endl);
+      trace->used_fregs[rdest] = 1;
+      break;
+    default:
+      std::abort();
+      break;
+    }
+  }
+
+  warp.PC += 4;
+
+  if (warp.PC != next_pc) {
+    DP(3, "*** Next PC=0x" << std::hex << next_pc << std::dec);
+    warp.PC = next_pc;
+  }
+
+  if (warp.tmask != next_tmask) {
+    DPH(3, "*** New Tmask=");
+    for (uint32_t i = 0; i < num_threads; ++i)
+      DPN(3, next_tmask.test(i));
+    DPN(3, std::endl);
+    warp.tmask = next_tmask;
+    if (!next_tmask.any()) {
+      active_warps_.reset(wid);
+    }
+  }
 }
\ No newline at end of file
diff --git a/sim/simx/func_unit.cpp b/sim/simx/func_unit.cpp
index 0d4a5b3..e8b973c 100644
--- a/sim/simx/func_unit.cpp
+++ b/sim/simx/func_unit.cpp
@@ -43,6 +43,10 @@ void AluUnit::tick() {
 		case AluType::IDIV:
 			output.push(trace, XLEN+1);
 			break;
+		case AluType::DOT8:
+			// TODO:
+			output.push(trace, 2);
+			break;
 		default:
 			std::abort();
 		}
diff --git a/sim/simx/types.h b/sim/simx/types.h
index ca293fe..aa529c4 100644
--- a/sim/simx/types.h
+++ b/sim/simx/types.h
@@ -1,592 +1,594 @@
-// Copyright © 2019-2023
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-// http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-#pragma once
-
-#include <stdint.h>
-#include <bitset>
-#include <queue>
-#include <vector>
-#include <unordered_map>
-#include <util.h>
-#include <stringutil.h>
-#include <VX_config.h>
-#include <simobject.h>
-#include "uuid_gen.h"
-#include "debug.h"
-
-namespace vortex {
-
-typedef uint8_t Byte;
-#if (XLEN == 32)
-typedef uint32_t Word;
-typedef int32_t  WordI;
-typedef uint64_t DWord;
-typedef int64_t  DWordI;
-typedef uint32_t WordF;
-#elif (XLEN == 64)
-typedef uint64_t Word;
-typedef int64_t  WordI;
-typedef __uint128_t DWord;
-typedef __int128_t DWordI;
-typedef uint64_t WordF;
-#else
-#error unsupported XLEN
-#endif
-
-#define MAX_NUM_CORES   1024
-#define MAX_NUM_THREADS 32
-#define MAX_NUM_WARPS   32
-#define MAX_NUM_REGS    32
-
-typedef std::bitset<MAX_NUM_CORES>   CoreMask;
-typedef std::bitset<MAX_NUM_REGS>    RegMask;
-typedef std::bitset<MAX_NUM_THREADS> ThreadMask;
-typedef std::bitset<MAX_NUM_WARPS>   WarpMask;
-
-///////////////////////////////////////////////////////////////////////////////
-
-enum class RegType {
-  None,
-  Integer,
-  Float
-};
-
-inline std::ostream &operator<<(std::ostream &os, const RegType& type) {
-  switch (type) {
-  case RegType::None: break;
-  case RegType::Integer: os << "x"; break;
-  case RegType::Float:   os << "f"; break;
-  default: assert(false);
-  }
-  return os;
-}
-
-///////////////////////////////////////////////////////////////////////////////
-
-enum class FUType {
-  ALU,
-  LSU,
-  FPU,
-  SFU,
-  Count
-};
-
-inline std::ostream &operator<<(std::ostream &os, const FUType& type) {
-  switch (type) {
-  case FUType::ALU: os << "ALU"; break;
-  case FUType::LSU: os << "LSU"; break;
-  case FUType::FPU: os << "FPU"; break;
-  case FUType::SFU: os << "SFU"; break;
-  default: assert(false);
-  }
-  return os;
-}
-
-///////////////////////////////////////////////////////////////////////////////
-
-enum class AluType {
-  ARITH,
-  BRANCH,
-  SYSCALL,
-  IMUL,
-  IDIV
-};
-
-inline std::ostream &operator<<(std::ostream &os, const AluType& type) {
-  switch (type) {
-  case AluType::ARITH:   os << "ARITH"; break;
-  case AluType::BRANCH:  os << "BRANCH"; break;
-  case AluType::SYSCALL: os << "SYSCALL"; break;
-  case AluType::IMUL:    os << "IMUL"; break;
-  case AluType::IDIV:    os << "IDIV"; break;
-  default: assert(false);
-  }
-  return os;
-}
-
-///////////////////////////////////////////////////////////////////////////////
-
-enum class LsuType {
-  LOAD,
-  STORE,
-  FENCE
-};
-
-inline std::ostream &operator<<(std::ostream &os, const LsuType& type) {
-  switch (type) {
-  case LsuType::LOAD:  os << "LOAD"; break;
-  case LsuType::STORE: os << "STORE"; break;
-  case LsuType::FENCE: os << "FENCE"; break;
-  default: assert(false);
-  }
-  return os;
-}
-
-///////////////////////////////////////////////////////////////////////////////
-
-enum class AddrType {
-  Global,
-  Shared,
-  IO
-};
-
-inline AddrType get_addr_type(uint64_t addr) {
-  if (addr >= IO_BASE_ADDR) {
-     return AddrType::IO;
-  }
-  if (LMEM_ENABLED) {
-    if (addr >= LMEM_BASE_ADDR && (addr-LMEM_BASE_ADDR) < (1 << LMEM_LOG_SIZE)) {
-        return AddrType::Shared;
-    }
-  }
-  return AddrType::Global;
-}
-
-inline std::ostream &operator<<(std::ostream &os, const AddrType& type) {
-  switch (type) {
-  case AddrType::Global: os << "Global"; break;
-  case AddrType::Shared: os << "Shared"; break;
-  case AddrType::IO:     os << "IO"; break;
-  default: assert(false);
-  }
-  return os;
-}
-
-///////////////////////////////////////////////////////////////////////////////
-
-struct mem_addr_size_t {
-  uint64_t addr;
-  uint32_t size;
-};
-
-///////////////////////////////////////////////////////////////////////////////
-
-enum class FpuType {
-  FNCP,
-  FMA,
-  FDIV,
-  FSQRT,
-  FCVT
-};
-
-inline std::ostream &operator<<(std::ostream &os, const FpuType& type) {
-  switch (type) {
-  case FpuType::FNCP:  os << "FNCP"; break;
-  case FpuType::FMA:   os << "FMA"; break;
-  case FpuType::FDIV:  os << "FDIV"; break;
-  case FpuType::FSQRT: os << "FSQRT"; break;
-  case FpuType::FCVT:  os << "FCVT"; break;
-  default: assert(false);
-  }
-  return os;
-}
-
-///////////////////////////////////////////////////////////////////////////////
-
-enum class SfuType {
-  TMC,
-  WSPAWN,
-  SPLIT,
-  JOIN,
-  BAR,
-  PRED,
-  CSRRW,
-  CSRRS,
-  CSRRC,
-  CMOV
-};
-
-inline std::ostream &operator<<(std::ostream &os, const SfuType& type) {
-  switch (type) {
-  case SfuType::TMC:    os << "TMC"; break;
-  case SfuType::WSPAWN: os << "WSPAWN"; break;
-  case SfuType::SPLIT:  os << "SPLIT"; break;
-  case SfuType::JOIN:   os << "JOIN"; break;
-  case SfuType::BAR:    os << "BAR"; break;
-  case SfuType::PRED:   os << "PRED"; break;
-  case SfuType::CSRRW:  os << "CSRRW"; break;
-  case SfuType::CSRRS:  os << "CSRRS"; break;
-  case SfuType::CSRRC:  os << "CSRRC"; break;
-  case SfuType::CMOV:   os << "CMOV"; break;
-  default: assert(false);
-  }
-  return os;
-}
-
-///////////////////////////////////////////////////////////////////////////////
-
-enum class ArbiterType {
-  Priority,
-  RoundRobin
-};
-
-inline std::ostream &operator<<(std::ostream &os, const ArbiterType& type) {
-  switch (type) {
-  case ArbiterType::Priority:   os << "Priority"; break;
-  case ArbiterType::RoundRobin: os << "RoundRobin"; break;
-  default: assert(false);
-  }
-  return os;
-}
-
-///////////////////////////////////////////////////////////////////////////////
-
-struct MemReq {
-  uint64_t addr;
-  bool     write;
-  AddrType type;
-  uint32_t tag;
-  uint32_t cid;
-  uint64_t uuid;
-
-  MemReq(uint64_t _addr = 0,
-          bool _write = false,
-          AddrType _type = AddrType::Global,
-          uint64_t _tag = 0,
-          uint32_t _cid = 0,
-          uint64_t _uuid = 0
-  ) : addr(_addr)
-    , write(_write)
-    , type(_type)
-    , tag(_tag)
-    , cid(_cid)
-    , uuid(_uuid)
-  {}
-};
-
-inline std::ostream &operator<<(std::ostream &os, const MemReq& req) {
-  os << "mem-" << (req.write ? "wr" : "rd") << ": ";
-  os << "addr=0x" << std::hex << req.addr << ", type=" << req.type;
-  os << std::dec << ", tag=" << req.tag << ", cid=" << req.cid;
-  os << " (#" << std::dec << req.uuid << ")";
-  return os;
-}
-
-///////////////////////////////////////////////////////////////////////////////
-
-struct MemRsp {
-  uint64_t tag;
-  uint32_t cid;
-  uint64_t uuid;
-
-  MemRsp(uint64_t _tag = 0, uint32_t _cid = 0, uint64_t _uuid = 0)
-    : tag (_tag)
-    , cid(_cid)
-    , uuid(_uuid)
-  {}
-};
-
-inline std::ostream &operator<<(std::ostream &os, const MemRsp& rsp) {
-  os << "mem-rsp: tag=" << rsp.tag << ", cid=" << rsp.cid;
-  os << " (#" << std::dec << rsp.uuid << ")";
-  return os;
-}
-
-///////////////////////////////////////////////////////////////////////////////
-
-template <typename T>
-class HashTable {
-public:
-  HashTable(uint32_t capacity)
-    : entries_(capacity)
-    , size_(0)
-  {}
-
-  bool empty() const {
-    return (0 == size_);
-  }
-
-  bool full() const {
-    return (size_ == entries_.size());
-  }
-
-  uint32_t size() const {
-    return size_;
-  }
-
-  bool contains(uint32_t index) const {
-    return entries_.at(index).first;
-  }
-
-  const T& at(uint32_t index) const {
-    auto& entry = entries_.at(index);
-    assert(entry.first);
-    return entry.second;
-  }
-
-  T& at(uint32_t index) {
-    auto& entry = entries_.at(index);
-    assert(entry.first);
-    return entry.second;
-  }
-
-  uint32_t allocate(const T& value) {
-    for (uint32_t i = 0, n = entries_.size(); i < n; ++i) {
-      auto& entry = entries_.at(i);
-      if (!entry.first) {
-        entry.first = true;
-        entry.second = value;
-        ++size_;
-        return i;
-      }
-    }
-    assert(false);
-    return -1;
-  }
-
-  void release(uint32_t index) {
-    auto& entry = entries_.at(index);
-    assert(entry.first);
-    entry.first = false;
-    --size_;
-  }
-
-  void clear() {
-    for (uint32_t i = 0, n = entries_.size(); i < n; ++i) {
-      auto& entry = entries_.at(i);
-      entry.first = false;
-    }
-    size_ = 0;
-  }
-
-private:
-  std::vector<std::pair<bool, T>> entries_;
-  uint32_t size_;
-};
-
-///////////////////////////////////////////////////////////////////////////////
-
-template <typename Type>
-class Mux : public SimObject<Mux<Type>> {
-public:
-  std::vector<SimPort<Type>> Inputs;
-  std::vector<SimPort<Type>> Outputs;
-
-  Mux(
-    const SimContext& ctx,
-    const char* name,
-    ArbiterType type,
-    uint32_t num_inputs,
-    uint32_t num_outputs = 1,
-    uint32_t delay = 1
-  ) : SimObject<Mux<Type>>(ctx, name)
-    , Inputs(num_inputs, this)
-    , Outputs(num_outputs, this)
-    , type_(type)
-    , delay_(delay)
-    , cursors_(num_outputs, 0)
-    , num_reqs_(num_inputs / num_outputs)
-  {
-    assert(delay != 0);
-    assert(num_inputs <= 32);
-    assert(num_outputs <= 32);
-    assert(num_inputs >= num_outputs);
-
-    // bypass mode
-    if (num_inputs == num_outputs) {
-      for (uint32_t i = 0; i < num_inputs; ++i) {
-        Inputs.at(i).bind(&Outputs.at(i));
-      }
-    }
-  }
-
-  void reset() {
-    for (auto& cursor : cursors_) {
-      cursor = 0;
-    }
-  }
-
-  void tick() {
-    uint32_t I = Inputs.size();
-    uint32_t O = Outputs.size();
-    uint32_t R = num_reqs_;
-
-    // skip bypass mode
-    if (I == O)
-      return;
-
-    // process inputs
-    for (uint32_t o = 0; o < O; ++o) {
-      for (uint32_t r = 0; r < R; ++r) {
-        uint32_t i = (cursors_.at(o) + r) & (R-1);
-        uint32_t j = o * R + i;
-        if (j >= I)
-          continue;
-
-        auto& req_in = Inputs.at(j);
-        if (!req_in.empty()) {
-          auto& req = req_in.front();
-          DT(4, this->name() << "-" << req);
-          Outputs.at(o).push(req, delay_);
-          req_in.pop();
-          this->update_cursor(o, i);
-          break;
-        }
-      }
-    }
-  }
-
-private:
-
-  void update_cursor(uint32_t index, uint32_t grant) {
-    if (type_ == ArbiterType::RoundRobin) {
-      cursors_.at(index) = grant + 1;
-    }
-  }
-
-  ArbiterType type_;
-  uint32_t delay_;
-  std::vector<uint32_t> cursors_;
-  uint32_t num_reqs_;
-};
-
-///////////////////////////////////////////////////////////////////////////////
-
-template <typename Req, typename Rsp>
-class Switch : public SimObject<Switch<Req, Rsp>> {
-public:
-  std::vector<SimPort<Req>>  ReqIn;
-  std::vector<SimPort<Rsp>>  RspIn;
-
-  std::vector<SimPort<Req>>  ReqOut;
-  std::vector<SimPort<Rsp>>  RspOut;
-
-  Switch(
-    const SimContext& ctx,
-    const char* name,
-    ArbiterType type,
-    uint32_t num_inputs,
-    uint32_t num_outputs = 1,
-    uint32_t delay = 1
-  )
-    : SimObject<Switch<Req, Rsp>>(ctx, name)
-    , ReqIn(num_inputs, this)
-    , RspIn(num_inputs, this)
-    , ReqOut(num_outputs, this)
-    , RspOut(num_outputs, this)
-    , type_(type)
-    , delay_(delay)
-    , cursors_(num_outputs, 0)
-    , lg_num_reqs_(log2ceil(num_inputs / num_outputs))
-  {
-    assert(delay != 0);
-    assert(num_inputs <= 32);
-    assert(num_outputs <= 32);
-    assert(num_inputs >= num_outputs);
-
-    // bypass mode
-    if (num_inputs == num_outputs) {
-      for (uint32_t i = 0; i < num_inputs; ++i) {
-        ReqIn.at(i).bind(&ReqOut.at(i));
-        RspOut.at(i).bind(&RspIn.at(i));
-      }
-    }
-  }
-
-  void reset() {
-    for (auto& cursor : cursors_) {
-      cursor = 0;
-    }
-  }
-
-  void tick() {
-    uint32_t I = ReqIn.size();
-    uint32_t O = ReqOut.size();
-    uint32_t R = 1 << lg_num_reqs_;
-
-    // skip bypass mode
-    if (I == O)
-      return;
-
-    for (uint32_t o = 0; o < O; ++o) {
-      // process incoming responses
-      if (!RspOut.at(o).empty()) {
-        auto& rsp = RspOut.at(o).front();
-        uint32_t i = 0;
-        if (lg_num_reqs_ != 0) {
-          i = rsp.tag & (R-1);
-          rsp.tag >>= lg_num_reqs_;
-        }
-        DT(4, this->name() << "-" << rsp);
-        uint32_t j = o * R + i;
-        RspIn.at(j).push(rsp, 1);
-        RspOut.at(o).pop();
-      }
-
-      // process incoming requests
-      for (uint32_t r = 0; r < R; ++r) {
-        uint32_t i = (cursors_.at(o) + r) & (R-1);
-        uint32_t j = o * R + i;
-        if (j >= I)
-          continue;
-
-        auto& req_in = ReqIn.at(j);
-        if (!req_in.empty()) {
-          auto& req = req_in.front();
-          if (lg_num_reqs_ != 0) {
-            req.tag = (req.tag << lg_num_reqs_) | i;
-          }
-          DT(4, this->name() << "-" << req);
-          ReqOut.at(o).push(req, delay_);
-          req_in.pop();
-          this->update_cursor(o, i);
-          break;
-        }
-      }
-    }
-  }
-
-  void update_cursor(uint32_t index, uint32_t grant) {
-    if (type_ == ArbiterType::RoundRobin) {
-      cursors_.at(index) = grant + 1;
-    }
-  }
-
-private:
-  ArbiterType type_;
-  uint32_t delay_;
-  std::vector<uint32_t> cursors_;
-  uint32_t lg_num_reqs_;
-};
-
-using MemSwitch = Switch<MemReq, MemRsp>;
-
-///////////////////////////////////////////////////////////////////////////////
-
-class LocalMemDemux : public SimObject<LocalMemDemux> {
-public:
-  SimPort<MemReq> ReqIn;
-  SimPort<MemRsp> RspIn;
-
-  SimPort<MemReq> ReqSM;
-  SimPort<MemRsp> RspSM;
-
-  SimPort<MemReq> ReqDC;
-  SimPort<MemRsp> RspDC;
-
-  LocalMemDemux(
-    const SimContext& ctx,
-    const char* name,
-    uint32_t delay
-  );
-
-  void reset();
-
-  void tick();
-
-private:
-  uint32_t delay_;
-};
-
-}
+// Copyright © 2019-2023
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#pragma once
+
+#include <stdint.h>
+#include <bitset>
+#include <queue>
+#include <vector>
+#include <unordered_map>
+#include <util.h>
+#include <stringutil.h>
+#include <VX_config.h>
+#include <simobject.h>
+#include "uuid_gen.h"
+#include "debug.h"
+
+namespace vortex {
+
+typedef uint8_t Byte;
+#if (XLEN == 32)
+typedef uint32_t Word;
+typedef int32_t  WordI;
+typedef uint64_t DWord;
+typedef int64_t  DWordI;
+typedef uint32_t WordF;
+#elif (XLEN == 64)
+typedef uint64_t Word;
+typedef int64_t  WordI;
+typedef __uint128_t DWord;
+typedef __int128_t DWordI;
+typedef uint64_t WordF;
+#else
+#error unsupported XLEN
+#endif
+
+#define MAX_NUM_CORES   1024
+#define MAX_NUM_THREADS 32
+#define MAX_NUM_WARPS   32
+#define MAX_NUM_REGS    32
+
+typedef std::bitset<MAX_NUM_CORES>   CoreMask;
+typedef std::bitset<MAX_NUM_REGS>    RegMask;
+typedef std::bitset<MAX_NUM_THREADS> ThreadMask;
+typedef std::bitset<MAX_NUM_WARPS>   WarpMask;
+
+///////////////////////////////////////////////////////////////////////////////
+
+enum class RegType {
+  None,
+  Integer,
+  Float
+};
+
+inline std::ostream &operator<<(std::ostream &os, const RegType& type) {
+  switch (type) {
+  case RegType::None: break;
+  case RegType::Integer: os << "x"; break;
+  case RegType::Float:   os << "f"; break;
+  default: assert(false);
+  }
+  return os;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+enum class FUType {
+  ALU,
+  LSU,
+  FPU,
+  SFU,
+  Count
+};
+
+inline std::ostream &operator<<(std::ostream &os, const FUType& type) {
+  switch (type) {
+  case FUType::ALU: os << "ALU"; break;
+  case FUType::LSU: os << "LSU"; break;
+  case FUType::FPU: os << "FPU"; break;
+  case FUType::SFU: os << "SFU"; break;
+  default: assert(false);
+  }
+  return os;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+enum class AluType {
+  ARITH,
+  BRANCH,
+  SYSCALL,
+  IMUL,
+  IDIV,
+  DOT8
+};
+
+inline std::ostream &operator<<(std::ostream &os, const AluType& type) {
+  switch (type) {
+  case AluType::ARITH:   os << "ARITH"; break;
+  case AluType::BRANCH:  os << "BRANCH"; break;
+  case AluType::SYSCALL: os << "SYSCALL"; break;
+  case AluType::IMUL:    os << "IMUL"; break;
+  case AluType::IDIV:    os << "IDIV"; break;
+  case AluType::DOT8:    os << "DOT8"; break;
+  default: assert(false);
+  }
+  return os;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+enum class LsuType {
+  LOAD,
+  STORE,
+  FENCE
+};
+
+inline std::ostream &operator<<(std::ostream &os, const LsuType& type) {
+  switch (type) {
+  case LsuType::LOAD:  os << "LOAD"; break;
+  case LsuType::STORE: os << "STORE"; break;
+  case LsuType::FENCE: os << "FENCE"; break;
+  default: assert(false);
+  }
+  return os;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+enum class AddrType {
+  Global,
+  Shared,
+  IO
+};
+
+inline AddrType get_addr_type(uint64_t addr) {
+  if (addr >= IO_BASE_ADDR) {
+     return AddrType::IO;
+  }
+  if (LMEM_ENABLED) {
+    if (addr >= LMEM_BASE_ADDR && (addr-LMEM_BASE_ADDR) < (1 << LMEM_LOG_SIZE)) {
+        return AddrType::Shared;
+    }
+  }
+  return AddrType::Global;
+}
+
+inline std::ostream &operator<<(std::ostream &os, const AddrType& type) {
+  switch (type) {
+  case AddrType::Global: os << "Global"; break;
+  case AddrType::Shared: os << "Shared"; break;
+  case AddrType::IO:     os << "IO"; break;
+  default: assert(false);
+  }
+  return os;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+struct mem_addr_size_t {
+  uint64_t addr;
+  uint32_t size;
+};
+
+///////////////////////////////////////////////////////////////////////////////
+
+enum class FpuType {
+  FNCP,
+  FMA,
+  FDIV,
+  FSQRT,
+  FCVT
+};
+
+inline std::ostream &operator<<(std::ostream &os, const FpuType& type) {
+  switch (type) {
+  case FpuType::FNCP:  os << "FNCP"; break;
+  case FpuType::FMA:   os << "FMA"; break;
+  case FpuType::FDIV:  os << "FDIV"; break;
+  case FpuType::FSQRT: os << "FSQRT"; break;
+  case FpuType::FCVT:  os << "FCVT"; break;
+  default: assert(false);
+  }
+  return os;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+enum class SfuType {
+  TMC,
+  WSPAWN,
+  SPLIT,
+  JOIN,
+  BAR,
+  PRED,
+  CSRRW,
+  CSRRS,
+  CSRRC,
+  CMOV
+};
+
+inline std::ostream &operator<<(std::ostream &os, const SfuType& type) {
+  switch (type) {
+  case SfuType::TMC:    os << "TMC"; break;
+  case SfuType::WSPAWN: os << "WSPAWN"; break;
+  case SfuType::SPLIT:  os << "SPLIT"; break;
+  case SfuType::JOIN:   os << "JOIN"; break;
+  case SfuType::BAR:    os << "BAR"; break;
+  case SfuType::PRED:   os << "PRED"; break;
+  case SfuType::CSRRW:  os << "CSRRW"; break;
+  case SfuType::CSRRS:  os << "CSRRS"; break;
+  case SfuType::CSRRC:  os << "CSRRC"; break;
+  case SfuType::CMOV:   os << "CMOV"; break;
+  default: assert(false);
+  }
+  return os;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+enum class ArbiterType {
+  Priority,
+  RoundRobin
+};
+
+inline std::ostream &operator<<(std::ostream &os, const ArbiterType& type) {
+  switch (type) {
+  case ArbiterType::Priority:   os << "Priority"; break;
+  case ArbiterType::RoundRobin: os << "RoundRobin"; break;
+  default: assert(false);
+  }
+  return os;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+struct MemReq {
+  uint64_t addr;
+  bool     write;
+  AddrType type;
+  uint32_t tag;
+  uint32_t cid;
+  uint64_t uuid;
+
+  MemReq(uint64_t _addr = 0,
+          bool _write = false,
+          AddrType _type = AddrType::Global,
+          uint64_t _tag = 0,
+          uint32_t _cid = 0,
+          uint64_t _uuid = 0
+  ) : addr(_addr)
+    , write(_write)
+    , type(_type)
+    , tag(_tag)
+    , cid(_cid)
+    , uuid(_uuid)
+  {}
+};
+
+inline std::ostream &operator<<(std::ostream &os, const MemReq& req) {
+  os << "mem-" << (req.write ? "wr" : "rd") << ": ";
+  os << "addr=0x" << std::hex << req.addr << ", type=" << req.type;
+  os << std::dec << ", tag=" << req.tag << ", cid=" << req.cid;
+  os << " (#" << std::dec << req.uuid << ")";
+  return os;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+struct MemRsp {
+  uint64_t tag;
+  uint32_t cid;
+  uint64_t uuid;
+
+  MemRsp(uint64_t _tag = 0, uint32_t _cid = 0, uint64_t _uuid = 0)
+    : tag (_tag)
+    , cid(_cid)
+    , uuid(_uuid)
+  {}
+};
+
+inline std::ostream &operator<<(std::ostream &os, const MemRsp& rsp) {
+  os << "mem-rsp: tag=" << rsp.tag << ", cid=" << rsp.cid;
+  os << " (#" << std::dec << rsp.uuid << ")";
+  return os;
+}
+
+///////////////////////////////////////////////////////////////////////////////
+
+template <typename T>
+class HashTable {
+public:
+  HashTable(uint32_t capacity)
+    : entries_(capacity)
+    , size_(0)
+  {}
+
+  bool empty() const {
+    return (0 == size_);
+  }
+
+  bool full() const {
+    return (size_ == entries_.size());
+  }
+
+  uint32_t size() const {
+    return size_;
+  }
+
+  bool contains(uint32_t index) const {
+    return entries_.at(index).first;
+  }
+
+  const T& at(uint32_t index) const {
+    auto& entry = entries_.at(index);
+    assert(entry.first);
+    return entry.second;
+  }
+
+  T& at(uint32_t index) {
+    auto& entry = entries_.at(index);
+    assert(entry.first);
+    return entry.second;
+  }
+
+  uint32_t allocate(const T& value) {
+    for (uint32_t i = 0, n = entries_.size(); i < n; ++i) {
+      auto& entry = entries_.at(i);
+      if (!entry.first) {
+        entry.first = true;
+        entry.second = value;
+        ++size_;
+        return i;
+      }
+    }
+    assert(false);
+    return -1;
+  }
+
+  void release(uint32_t index) {
+    auto& entry = entries_.at(index);
+    assert(entry.first);
+    entry.first = false;
+    --size_;
+  }
+
+  void clear() {
+    for (uint32_t i = 0, n = entries_.size(); i < n; ++i) {
+      auto& entry = entries_.at(i);
+      entry.first = false;
+    }
+    size_ = 0;
+  }
+
+private:
+  std::vector<std::pair<bool, T>> entries_;
+  uint32_t size_;
+};
+
+///////////////////////////////////////////////////////////////////////////////
+
+template <typename Type>
+class Mux : public SimObject<Mux<Type>> {
+public:
+  std::vector<SimPort<Type>> Inputs;
+  std::vector<SimPort<Type>> Outputs;
+
+  Mux(
+    const SimContext& ctx,
+    const char* name,
+    ArbiterType type,
+    uint32_t num_inputs,
+    uint32_t num_outputs = 1,
+    uint32_t delay = 1
+  ) : SimObject<Mux<Type>>(ctx, name)
+    , Inputs(num_inputs, this)
+    , Outputs(num_outputs, this)
+    , type_(type)
+    , delay_(delay)
+    , cursors_(num_outputs, 0)
+    , num_reqs_(num_inputs / num_outputs)
+  {
+    assert(delay != 0);
+    assert(num_inputs <= 32);
+    assert(num_outputs <= 32);
+    assert(num_inputs >= num_outputs);
+
+    // bypass mode
+    if (num_inputs == num_outputs) {
+      for (uint32_t i = 0; i < num_inputs; ++i) {
+        Inputs.at(i).bind(&Outputs.at(i));
+      }
+    }
+  }
+
+  void reset() {
+    for (auto& cursor : cursors_) {
+      cursor = 0;
+    }
+  }
+
+  void tick() {
+    uint32_t I = Inputs.size();
+    uint32_t O = Outputs.size();
+    uint32_t R = num_reqs_;
+
+    // skip bypass mode
+    if (I == O)
+      return;
+
+    // process inputs
+    for (uint32_t o = 0; o < O; ++o) {
+      for (uint32_t r = 0; r < R; ++r) {
+        uint32_t i = (cursors_.at(o) + r) & (R-1);
+        uint32_t j = o * R + i;
+        if (j >= I)
+          continue;
+
+        auto& req_in = Inputs.at(j);
+        if (!req_in.empty()) {
+          auto& req = req_in.front();
+          DT(4, this->name() << "-" << req);
+          Outputs.at(o).push(req, delay_);
+          req_in.pop();
+          this->update_cursor(o, i);
+          break;
+        }
+      }
+    }
+  }
+
+private:
+
+  void update_cursor(uint32_t index, uint32_t grant) {
+    if (type_ == ArbiterType::RoundRobin) {
+      cursors_.at(index) = grant + 1;
+    }
+  }
+
+  ArbiterType type_;
+  uint32_t delay_;
+  std::vector<uint32_t> cursors_;
+  uint32_t num_reqs_;
+};
+
+///////////////////////////////////////////////////////////////////////////////
+
+template <typename Req, typename Rsp>
+class Switch : public SimObject<Switch<Req, Rsp>> {
+public:
+  std::vector<SimPort<Req>>  ReqIn;
+  std::vector<SimPort<Rsp>>  RspIn;
+
+  std::vector<SimPort<Req>>  ReqOut;
+  std::vector<SimPort<Rsp>>  RspOut;
+
+  Switch(
+    const SimContext& ctx,
+    const char* name,
+    ArbiterType type,
+    uint32_t num_inputs,
+    uint32_t num_outputs = 1,
+    uint32_t delay = 1
+  )
+    : SimObject<Switch<Req, Rsp>>(ctx, name)
+    , ReqIn(num_inputs, this)
+    , RspIn(num_inputs, this)
+    , ReqOut(num_outputs, this)
+    , RspOut(num_outputs, this)
+    , type_(type)
+    , delay_(delay)
+    , cursors_(num_outputs, 0)
+    , lg_num_reqs_(log2ceil(num_inputs / num_outputs))
+  {
+    assert(delay != 0);
+    assert(num_inputs <= 32);
+    assert(num_outputs <= 32);
+    assert(num_inputs >= num_outputs);
+
+    // bypass mode
+    if (num_inputs == num_outputs) {
+      for (uint32_t i = 0; i < num_inputs; ++i) {
+        ReqIn.at(i).bind(&ReqOut.at(i));
+        RspOut.at(i).bind(&RspIn.at(i));
+      }
+    }
+  }
+
+  void reset() {
+    for (auto& cursor : cursors_) {
+      cursor = 0;
+    }
+  }
+
+  void tick() {
+    uint32_t I = ReqIn.size();
+    uint32_t O = ReqOut.size();
+    uint32_t R = 1 << lg_num_reqs_;
+
+    // skip bypass mode
+    if (I == O)
+      return;
+
+    for (uint32_t o = 0; o < O; ++o) {
+      // process incoming responses
+      if (!RspOut.at(o).empty()) {
+        auto& rsp = RspOut.at(o).front();
+        uint32_t i = 0;
+        if (lg_num_reqs_ != 0) {
+          i = rsp.tag & (R-1);
+          rsp.tag >>= lg_num_reqs_;
+        }
+        DT(4, this->name() << "-" << rsp);
+        uint32_t j = o * R + i;
+        RspIn.at(j).push(rsp, 1);
+        RspOut.at(o).pop();
+      }
+
+      // process incoming requests
+      for (uint32_t r = 0; r < R; ++r) {
+        uint32_t i = (cursors_.at(o) + r) & (R-1);
+        uint32_t j = o * R + i;
+        if (j >= I)
+          continue;
+
+        auto& req_in = ReqIn.at(j);
+        if (!req_in.empty()) {
+          auto& req = req_in.front();
+          if (lg_num_reqs_ != 0) {
+            req.tag = (req.tag << lg_num_reqs_) | i;
+          }
+          DT(4, this->name() << "-" << req);
+          ReqOut.at(o).push(req, delay_);
+          req_in.pop();
+          this->update_cursor(o, i);
+          break;
+        }
+      }
+    }
+  }
+
+  void update_cursor(uint32_t index, uint32_t grant) {
+    if (type_ == ArbiterType::RoundRobin) {
+      cursors_.at(index) = grant + 1;
+    }
+  }
+
+private:
+  ArbiterType type_;
+  uint32_t delay_;
+  std::vector<uint32_t> cursors_;
+  uint32_t lg_num_reqs_;
+};
+
+using MemSwitch = Switch<MemReq, MemRsp>;
+
+///////////////////////////////////////////////////////////////////////////////
+
+class LocalMemDemux : public SimObject<LocalMemDemux> {
+public:
+  SimPort<MemReq> ReqIn;
+  SimPort<MemRsp> RspIn;
+
+  SimPort<MemReq> ReqSM;
+  SimPort<MemRsp> RspSM;
+
+  SimPort<MemReq> ReqDC;
+  SimPort<MemRsp> RspDC;
+
+  LocalMemDemux(
+    const SimContext& ctx,
+    const char* name,
+    uint32_t delay
+  );
+
+  void reset();
+
+  void tick();
+
+private:
+  uint32_t delay_;
+};
+
+}
diff --git a/tests/regression/Makefile b/tests/regression/Makefile
index 36412c8..1f4298a 100644
--- a/tests/regression/Makefile
+++ b/tests/regression/Makefile
@@ -14,6 +14,9 @@ all:
 	$(MAKE) -C vecaddx
 	$(MAKE) -C sgemmx
 	$(MAKE) -C conv3x
+	$(MAKE) -C dot8
+	$(MAKE) -C sgemm8
+	$(MAKE) -C sgemm8_sm
 
 run-simx:
 	$(MAKE) -C basic run-simx
@@ -28,6 +31,9 @@ run-simx:
 	$(MAKE) -C vecaddx run-simx
 	$(MAKE) -C sgemmx run-simx
 	$(MAKE) -C conv3x run-simx
+	$(MAKE) -C dot8 run-simx
+	$(MAKE) -C sgemm8 run-simx
+	$(MAKE) -C sgemm8_sm run-simx
 
 run-rtlsim:
 	$(MAKE) -C basic run-rtlsim
@@ -42,6 +48,9 @@ run-rtlsim:
 	$(MAKE) -C vecaddx run-rtlsim
 	$(MAKE) -C sgemmx run-rtlsim
 	$(MAKE) -C conv3x run-rtlsim
+	$(MAKE) -C dot8 run-rtlsim
+	$(MAKE) -C sgemm8 run-rtlsim
+	$(MAKE) -C sgemm8_sm run-rtlsim
 
 run-opae:
 	$(MAKE) -C basic run-opae
@@ -56,6 +65,9 @@ run-opae:
 	$(MAKE) -C vecaddx run-opae
 	$(MAKE) -C sgemmx run-opae
 	$(MAKE) -C conv3x run-opae
+	$(MAKE) -C dot8 run-opae
+	$(MAKE) -C sgemm8 run-opae
+	$(MAKE) -C sgemm8_sm run-opae
 
 clean:
 	$(MAKE) -C basic clean
@@ -70,6 +82,9 @@ clean:
 	$(MAKE) -C vecaddx clean
 	$(MAKE) -C sgemmx clean
 	$(MAKE) -C conv3x clean
+	$(MAKE) -C dot8 clean
+	$(MAKE) -C sgemm8 clean
+	$(MAKE) -C sgemm8_sm clean
 
 clean-all:
 	$(MAKE) -C basic clean-all
@@ -84,3 +99,6 @@ clean-all:
 	$(MAKE) -C vecaddx clean-all
 	$(MAKE) -C sgemmx clean-all
 	$(MAKE) -C conv3x clean-all
+	$(MAKE) -C dot8 clean-all
+	$(MAKE) -C sgemm8 clean-all
+	$(MAKE) -C sgemm8_sm clean-all
diff --git a/tests/regression/dot8/Makefile b/tests/regression/dot8/Makefile
new file mode 100644
index 0000000..64a7bcb
--- /dev/null
+++ b/tests/regression/dot8/Makefile
@@ -0,0 +1,14 @@
+ROOT_DIR := $(realpath ../../..)
+include $(ROOT_DIR)/config.mk
+
+PROJECT := dot8
+
+SRC_DIR := $(VORTEX_HOME)/tests/regression/$(PROJECT)
+
+SRCS := $(SRC_DIR)/main.cpp
+
+VX_SRCS := $(SRC_DIR)/kernel.cpp
+
+OPTS ?= -n16
+
+include ../common.mk
\ No newline at end of file
diff --git a/tests/regression/dot8/common.h b/tests/regression/dot8/common.h
new file mode 100644
index 0000000..4a54a7b
--- /dev/null
+++ b/tests/regression/dot8/common.h
@@ -0,0 +1,11 @@
+#ifndef _COMMON_H_
+#define _COMMON_H_
+
+typedef struct {
+  uint32_t num_tasks;
+  uint64_t A_addr;
+  uint64_t B_addr;
+  uint64_t C_addr;
+} kernel_arg_t;
+
+#endif
\ No newline at end of file
diff --git a/tests/regression/dot8/kernel.cpp b/tests/regression/dot8/kernel.cpp
new file mode 100644
index 0000000..f7d81aa
--- /dev/null
+++ b/tests/regression/dot8/kernel.cpp
@@ -0,0 +1,23 @@
+#include <stdint.h>
+#include <vx_intrinsics.h>
+#include <vx_spawn.h>
+#include <vx_print.h>
+#include "common.h"
+
+void kernel_body(int task_id, kernel_arg_t *arg) {
+	auto A_ptr = reinterpret_cast<int*>(arg->A_addr);
+	auto B_ptr = reinterpret_cast<int*>(arg->B_addr);
+	auto C_ptr = reinterpret_cast<int*>(arg->C_addr);
+
+	int a = A_ptr[task_id];
+	int b = B_ptr[task_id];
+	int c = vx_dot8(a, b);
+
+	C_ptr[task_id] = c;
+}
+
+int main() {
+	kernel_arg_t* arg = (kernel_arg_t*)csr_read(VX_CSR_MSCRATCH);
+	vx_spawn_tasks(arg->num_tasks, (vx_spawn_tasks_cb)kernel_body, arg);
+	return 0;
+}
\ No newline at end of file
diff --git a/tests/regression/dot8/main.cpp b/tests/regression/dot8/main.cpp
new file mode 100644
index 0000000..9b86615
--- /dev/null
+++ b/tests/regression/dot8/main.cpp
@@ -0,0 +1,190 @@
+#include <iostream>
+#include <unistd.h>
+#include <string.h>
+#include <vector>
+#include <vortex.h>
+#include "common.h"
+
+#define FLOAT_ULP 6
+
+#define RT_CHECK(_expr)                                         \
+   do {                                                         \
+     int _ret = _expr;                                          \
+     if (0 == _ret)                                             \
+       break;                                                   \
+     printf("Error: '%s' returned %d!\n", #_expr, (int)_ret);   \
+	 cleanup();			                                              \
+     exit(-1);                                                  \
+   } while (false)
+
+///////////////////////////////////////////////////////////////////////////////
+
+static void generate_gold(int* out, int* A, int* B, uint32_t size) {
+  for (uint32_t i = 0; i < size; ++i) {
+    int a = A[i];
+    int b = B[i];
+
+    int a0 = (a >> 0) & 0xff;
+    int a1 = (a >> 8) & 0xff;
+    int a2 = (a >> 16) & 0xff;
+    int a3 = (a >> 24) & 0xff;
+
+    int b0 = (b >> 0) & 0xff;
+    int b1 = (b >> 8) & 0xff;
+    int b2 = (b >> 16) & 0xff;
+    int b3 = (b >> 24) & 0xff;
+
+    int c = a0 * b0 + a1 * b1 + a2 * b2 + a3 * b3;
+
+    out[i] = c;
+  }
+}
+
+const char* kernel_file = "kernel.vxbin";
+
+uint32_t size = 16;
+
+vx_device_h device = nullptr;
+vx_buffer_h A_buffer = nullptr;
+vx_buffer_h B_buffer = nullptr;
+vx_buffer_h C_buffer = nullptr;
+vx_buffer_h krnl_buffer = nullptr;
+vx_buffer_h args_buffer = nullptr;
+kernel_arg_t kernel_arg = {};
+
+static void show_usage() {
+   std::cout << "Vortex Test." << std::endl;
+   std::cout << "Usage: [-k: kernel] [-n words] [-h: help]" << std::endl;
+}
+
+static void parse_args(int argc, char **argv) {
+  int c;
+  while ((c = getopt(argc, argv, "n:k:h?")) != -1) {
+    switch (c) {
+    case 'n':
+      size = atoi(optarg);
+      break;
+    case 'k':
+      kernel_file = optarg;
+      break;
+    case 'h':
+    case '?': {
+      show_usage();
+      exit(0);
+    } break;
+    default:
+      show_usage();
+      exit(-1);
+    }
+  }
+}
+
+void cleanup() {
+  if (device) {
+    vx_mem_free(A_buffer);
+    vx_mem_free(B_buffer);
+    vx_mem_free(C_buffer);
+    vx_mem_free(krnl_buffer);
+    vx_mem_free(args_buffer);
+    vx_dev_close(device);
+  }
+}
+
+int main(int argc, char *argv[]) {
+  // parse command arguments
+  parse_args(argc, argv);
+
+  std::srand(50);
+
+  // open device connection
+  std::cout << "open device connection" << std::endl;
+  RT_CHECK(vx_dev_open(&device));
+
+  uint32_t buf_size = size * sizeof(int);
+
+  std::cout << "size: " << size << std::endl;
+
+  kernel_arg.num_tasks = size;
+
+  // allocate device memory
+  std::cout << "allocate device memory" << std::endl;
+  RT_CHECK(vx_mem_alloc(device, buf_size, VX_MEM_READ, &A_buffer));
+  RT_CHECK(vx_mem_address(A_buffer, &kernel_arg.A_addr));
+  RT_CHECK(vx_mem_alloc(device, buf_size, VX_MEM_READ, &B_buffer));
+  RT_CHECK(vx_mem_address(B_buffer, &kernel_arg.B_addr));
+  RT_CHECK(vx_mem_alloc(device, buf_size, VX_MEM_WRITE, &C_buffer));
+  RT_CHECK(vx_mem_address(C_buffer, &kernel_arg.C_addr));
+
+  std::cout << "A_addr=0x" << std::hex << kernel_arg.A_addr << std::endl;
+  std::cout << "B_addr=0x" << std::hex << kernel_arg.B_addr << std::endl;
+  std::cout << "C_addr=0x" << std::hex << kernel_arg.C_addr << std::endl;
+
+  // allocate host buffers
+  std::cout << "allocate host buffers" << std::endl;
+  std::vector<int> h_A(size);
+  std::vector<int> h_B(size);
+  std::vector<int> h_C(size);
+
+  // generate source data
+  for (uint32_t i = 0; i < size; ++i) {
+    h_A[i] = rand();
+    h_B[i] = rand();
+  }
+
+  // upload source buffer0
+  std::cout << "upload source buffer0" << std::endl;
+  RT_CHECK(vx_copy_to_dev(A_buffer, h_A.data(), 0, buf_size));
+
+  // upload source buffer1
+  std::cout << "upload source buffer1" << std::endl;
+  RT_CHECK(vx_copy_to_dev(B_buffer, h_B.data(), 0, buf_size));
+
+  // upload program
+  std::cout << "upload program" << std::endl;
+  RT_CHECK(vx_upload_kernel_file(device, kernel_file, &krnl_buffer));
+
+  // upload kernel argument
+  std::cout << "upload kernel argument" << std::endl;
+  RT_CHECK(vx_upload_bytes(device, &kernel_arg, sizeof(kernel_arg_t), &args_buffer));
+
+  // start device
+  std::cout << "start device" << std::endl;
+  RT_CHECK(vx_start(device, krnl_buffer, args_buffer));
+
+  // wait for completion
+  std::cout << "wait for completion" << std::endl;
+  RT_CHECK(vx_ready_wait(device, VX_MAX_TIMEOUT));
+
+  // download destination buffer
+  std::cout << "download destination buffer" << std::endl;
+  RT_CHECK(vx_copy_from_dev(h_C.data(), C_buffer, 0, buf_size));
+
+  // verify result
+  std::cout << "verify result" << std::endl;
+  int errors = 0;
+  {
+    std::vector<int> h_ref(size);
+    generate_gold(h_ref.data(), h_A.data(), h_B.data(), size);
+
+    for (uint32_t i = 0; i < size; ++i) {
+      if (h_C[i] != h_ref[i]) {
+        std::cout << "error: mismatch at index " << std::dec << i << ": expected 0x"
+                  << std::hex << h_C[i] << ", actual 0x" << h_ref[i] << std::endl;
+        ++errors;
+      }
+    }
+  }
+  // cleanup
+  std::cout << "cleanup" << std::endl;
+  cleanup();
+
+  if (errors != 0) {
+    std::cout << "Found " << std::dec << errors << " errors!" << std::endl;
+    std::cout << "FAILED!" << std::endl;
+    return errors;
+  }
+
+  std::cout << "PASSED!" << std::endl;
+
+  return 0;
+}
\ No newline at end of file
diff --git a/tests/regression/sgemm2x/kernel.cpp b/tests/regression/sgemm2x/kernel.cpp
index 58eba2a..45f23a4 100644
--- a/tests/regression/sgemm2x/kernel.cpp
+++ b/tests/regression/sgemm2x/kernel.cpp
@@ -10,7 +10,7 @@ void kernel_body(int local_task_id, int group_id, int local_group_id, int warps_
 	auto B_ptr     = reinterpret_cast<TYPE*>(arg->B_addr);
 	auto C_ptr     = reinterpret_cast<TYPE*>(arg->C_addr);
 	auto size      = arg->size;
-  auto tile_size = arg->tile_size;
+  	auto tile_size = arg->tile_size;
 	auto num_groups = arg->num_groups;
 	auto group_size = arg->group_size;
 	auto num_tiles = size / tile_size;
@@ -21,7 +21,7 @@ void kernel_body(int local_task_id, int group_id, int local_group_id, int warps_
 
 	// Determine row and column indices of the current task
 	auto g_row = (group_id / num_tiles) * tile_size + l_row;
-  auto g_col = (group_id % num_tiles) * tile_size + l_col;
+  	auto g_col = (group_id % num_tiles) * tile_size + l_col;
 
 	// Allocate local memory for the tile of matrix A & B
 	auto local_A = local_ptr + local_group_id * group_size * 2;
@@ -50,7 +50,7 @@ void kernel_body(int local_task_id, int group_id, int local_group_id, int warps_
 	// Store the computed sum into the result matrix C
 	C_ptr[g_row * size + g_col] = sum;
 }
-
+ 
 int main() {
 	kernel_arg_t* arg = (kernel_arg_t*)csr_read(VX_CSR_MSCRATCH);
 	vx_spawn_task_groups(arg->num_groups, arg->group_size, (vx_spawn_task_groups_cb)kernel_body, arg);
diff --git a/tests/regression/sgemm8/Makefile b/tests/regression/sgemm8/Makefile
new file mode 100644
index 0000000..f3aef3b
--- /dev/null
+++ b/tests/regression/sgemm8/Makefile
@@ -0,0 +1,14 @@
+ROOT_DIR := $(realpath ../../..)
+include $(ROOT_DIR)/config.mk
+
+PROJECT := sgemm8
+
+SRC_DIR := $(VORTEX_HOME)/tests/regression/$(PROJECT)
+
+SRCS := $(SRC_DIR)/main.cpp
+
+VX_SRCS := $(SRC_DIR)/kernel.cpp
+
+OPTS ?= -n32
+
+include ../common.mk
\ No newline at end of file
diff --git a/tests/regression/sgemm8/common.h b/tests/regression/sgemm8/common.h
new file mode 100644
index 0000000..af8c76c
--- /dev/null
+++ b/tests/regression/sgemm8/common.h
@@ -0,0 +1,13 @@
+#ifndef _COMMON_H_
+#define _COMMON_H_
+
+typedef struct {
+  uint32_t num_tasks;
+  uint32_t size;
+  uint32_t log2_size;
+  uint64_t A_addr;
+  uint64_t B_addr;
+  uint64_t C_addr;  
+} kernel_arg_t;
+
+#endif
diff --git a/tests/regression/sgemm8/kernel.cpp b/tests/regression/sgemm8/kernel.cpp
new file mode 100644
index 0000000..6d2da5e
--- /dev/null
+++ b/tests/regression/sgemm8/kernel.cpp
@@ -0,0 +1,52 @@
+#include <stdint.h>
+#include <vx_intrinsics.h>
+#include <vx_spawn.h>
+#include "common.h"
+
+inline char is_log2(uint32_t x) {
+    return ((x & (x-1)) == 0);
+}
+
+void kernel_body(uint32_t task_id, kernel_arg_t* __UNIFORM__ arg) {
+	auto A = reinterpret_cast<int8_t*>(arg->A_addr);
+	auto B = reinterpret_cast<int8_t*>(arg->B_addr);
+	auto C = reinterpret_cast<int32_t*>(arg->C_addr);
+    auto size = arg->size;
+
+    uint32_t row, col;
+    if (is_log2(size)) {
+        row = task_id >> arg->log2_size;
+        col = task_id & (size-1);
+    } else {
+        row = task_id / size;
+        col = task_id % size;
+    }
+
+    // int32_t sum(0);
+    // for (int e = 0; e < size; ++e) {
+    //     sum += A[row * size + e] * B[e * size + col];
+    // }
+
+    int32_t sum(0);
+    for (int e = 0; e < size; e += 4) {
+        // (row * size) + index 
+        uint32_t packed_a = *(uint32_t*)&A[row * size + e + 0];
+
+        // index * size + col
+        uint8_t b0 = B[(e + 0) * size + col];
+        uint8_t b1 = B[(e + 1) * size + col];
+        uint8_t b2 = B[(e + 2) * size + col];
+        uint8_t b3 = B[(e + 3) * size + col];
+        uint32_t packed_b = ((uint32_t)b3 << 24) | ((uint32_t)b2 << 16) | ((uint32_t)b1 << 8) | (uint32_t)b0;
+
+        sum += vx_dot8(packed_a, packed_b);
+    }
+
+    C[task_id] = sum;
+}
+
+int main() {
+	kernel_arg_t* arg = (kernel_arg_t*)csr_read(VX_CSR_MSCRATCH);
+	vx_spawn_tasks(arg->num_tasks, (vx_spawn_tasks_cb)kernel_body, arg);
+	return 0;
+}
diff --git a/tests/regression/sgemm8/main.cpp b/tests/regression/sgemm8/main.cpp
new file mode 100644
index 0000000..367d0ec
--- /dev/null
+++ b/tests/regression/sgemm8/main.cpp
@@ -0,0 +1,266 @@
+#include <iostream>
+#include <unistd.h>
+#include <string.h>
+#include <vector>
+#include <chrono>
+#include <vortex.h>
+#include <cmath>
+#include "common.h"
+
+#define FLOAT_ULP 6
+
+#define RT_CHECK(_expr)                                         \
+   do {                                                         \
+     int _ret = _expr;                                          \
+     if (0 == _ret)                                             \
+       break;                                                   \
+     printf("Error: '%s' returned %d!\n", #_expr, (int)_ret);   \
+	 cleanup();			                                              \
+     exit(-1);                                                  \
+   } while (false)
+
+///////////////////////////////////////////////////////////////////////////////
+
+template <typename Type>
+class Comparator {};
+
+template <>
+class Comparator<int8_t> {
+public:
+  static const char* type_str() {
+    return "int8";
+  }
+  static int generate() {
+    return (rand() * 256) / RAND_MAX;
+  }
+  static bool compare(int a, int b, int index, int errors) {
+    if (a != b) {
+      if (errors < 100) {
+        printf("*** error: [%d] expected=%d, actual=%d\n", index, b, a);
+      }
+      return false;
+    }
+    return true;
+  }
+};
+
+template <>
+class Comparator<int> {
+public:
+  static const char* type_str() {
+    return "integer";
+  }
+  static int generate() {
+    return rand();
+  }
+  static bool compare(int a, int b, int index, int errors) {
+    if (a != b) {
+      if (errors < 100) {
+        printf("*** error: [%d] expected=%d, actual=%d\n", index, b, a);
+      }
+      return false;
+    }
+    return true;
+  }
+};
+
+template <>
+class Comparator<float> {
+public:
+  static const char* type_str() {
+    return "float";
+  }
+  static int generate() {
+    return static_cast<float>(rand()) / RAND_MAX;
+  }
+  static bool compare(float a, float b, int index, int errors) {
+    union fi_t { float f; int32_t i; };
+    fi_t fa, fb;
+    fa.f = a;
+    fb.f = b;
+    auto d = std::abs(fa.i - fb.i);
+    if (d > FLOAT_ULP) {
+      if (errors < 100) {
+        printf("*** error: [%d] expected=%f, actual=%f\n", index, b, a);
+      }
+      return false;
+    }
+    return true;
+  }
+};
+
+static void matmul_cpu(int32_t* out, const int8_t* A, const int8_t* B, uint32_t width, uint32_t height) {
+  for (uint32_t row = 0; row < height; ++row) {
+    for (uint32_t col = 0; col < width; ++col) {
+      int32_t sum(0);
+      for (uint32_t e = 0; e < width; ++e) {
+          sum += A[row * width + e] * B[e * width + col];
+      }
+      out[row * width + col] = sum;
+    }
+  }
+}
+
+const char* kernel_file = "kernel.vxbin";
+uint32_t size = 32;
+
+vx_device_h device = nullptr;
+vx_buffer_h A_buffer = nullptr;
+vx_buffer_h B_buffer = nullptr;
+vx_buffer_h C_buffer = nullptr;
+vx_buffer_h krnl_buffer = nullptr;
+vx_buffer_h args_buffer = nullptr;
+kernel_arg_t kernel_arg = {};
+
+static void show_usage() {
+   std::cout << "Vortex Test." << std::endl;
+   std::cout << "Usage: [-k: kernel] [-n size] [-h: help]" << std::endl;
+}
+
+static void parse_args(int argc, char **argv) {
+  int c;
+  while ((c = getopt(argc, argv, "n:k:h?")) != -1) {
+    switch (c) {
+    case 'n':
+      size = atoi(optarg);
+      break;
+    case 'k':
+      kernel_file = optarg;
+      break;
+    case 'h':
+    case '?': {
+      show_usage();
+      exit(0);
+    } break;
+    default:
+      show_usage();
+      exit(-1);
+    }
+  }
+}
+
+void cleanup() {
+  if (device) {
+    vx_mem_free(A_buffer);
+    vx_mem_free(B_buffer);
+    vx_mem_free(C_buffer);
+    vx_mem_free(krnl_buffer);
+    vx_mem_free(args_buffer);
+    vx_dev_close(device);
+  }
+}
+
+int main(int argc, char *argv[]) {
+  // parse command arguments
+  parse_args(argc, argv);
+
+  if(size % 4 != 0){
+    std::cout << "Matrix size must be multiple of 4!" << std::endl;
+    return -1;
+  }
+
+  std::srand(50);
+
+  // open device connection
+  std::cout << "open device connection" << std::endl;
+  RT_CHECK(vx_dev_open(&device));
+
+  uint32_t size_sq = size * size;
+  uint32_t buf_src_size = size_sq * sizeof(int8_t);
+  uint32_t buf_dst_size = size_sq * sizeof(int32_t);
+
+  std::cout << "data type: " << Comparator<int8_t>::type_str() << std::endl;
+  std::cout << "matrix size: " << size << "x" << size << std::endl;
+
+  kernel_arg.num_tasks = size_sq;
+  kernel_arg.size = size;
+  kernel_arg.log2_size = log2(size);
+
+  // allocate device memory
+  std::cout << "allocate device memory" << std::endl;
+  RT_CHECK(vx_mem_alloc(device, buf_src_size, VX_MEM_READ, &A_buffer));
+  RT_CHECK(vx_mem_address(A_buffer, &kernel_arg.A_addr));
+  RT_CHECK(vx_mem_alloc(device, buf_src_size, VX_MEM_READ, &B_buffer));
+  RT_CHECK(vx_mem_address(B_buffer, &kernel_arg.B_addr));
+  RT_CHECK(vx_mem_alloc(device, buf_dst_size, VX_MEM_WRITE, &C_buffer));
+  RT_CHECK(vx_mem_address(C_buffer, &kernel_arg.C_addr));
+
+  std::cout << "A_addr=0x" << std::hex << kernel_arg.A_addr << std::endl;
+  std::cout << "B_addr=0x" << std::hex << kernel_arg.B_addr << std::endl;
+  std::cout << "C_addr=0x" << std::hex << kernel_arg.C_addr << std::endl;
+
+  // generate source data
+  std::vector<int8_t> h_A(size_sq);
+  std::vector<int8_t> h_B(size_sq);
+  std::vector<int32_t> h_C(size_sq);
+  for (uint32_t i = 0; i < size_sq; ++i) {
+    h_A[i] = Comparator<int8_t>::generate();
+    h_B[i] = Comparator<int8_t>::generate();
+  }
+
+  // upload matrix A buffer
+  {
+    std::cout << "upload matrix A buffer" << std::endl;
+    RT_CHECK(vx_copy_to_dev(A_buffer, h_A.data(), 0, buf_src_size));
+  }
+
+  // upload matrix B buffer
+  {
+    std::cout << "upload matrix B buffer" << std::endl;
+    RT_CHECK(vx_copy_to_dev(B_buffer, h_B.data(), 0, buf_src_size));
+  }
+
+  // upload program
+  std::cout << "upload program" << std::endl;
+  RT_CHECK(vx_upload_kernel_file(device, kernel_file, &krnl_buffer));
+
+  // upload kernel argument
+  std::cout << "upload kernel argument" << std::endl;
+  RT_CHECK(vx_upload_bytes(device, &kernel_arg, sizeof(kernel_arg_t), &args_buffer));
+
+  auto time_start = std::chrono::high_resolution_clock::now();
+
+  // start device
+  std::cout << "start device" << std::endl;
+  RT_CHECK(vx_start(device, krnl_buffer, args_buffer));
+
+  // wait for completion
+  std::cout << "wait for completion" << std::endl;
+  RT_CHECK(vx_ready_wait(device, VX_MAX_TIMEOUT));
+
+  auto time_end = std::chrono::high_resolution_clock::now();
+  double elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(time_end - time_start).count();
+  printf("Elapsed time: %lg ms\n", elapsed);
+
+  // download destination buffer
+  std::cout << "download destination buffer" << std::endl;
+  RT_CHECK(vx_copy_from_dev(h_C.data(), C_buffer, 0, buf_dst_size));
+
+  // verify result
+  std::cout << "verify result" << std::endl;
+  int errors = 0;
+  {
+    std::vector<int32_t> h_ref(size_sq);
+    matmul_cpu(h_ref.data(), h_A.data(), h_B.data(), size, size);
+
+    for (uint32_t i = 0; i < h_ref.size(); ++i) {
+      if (!Comparator<int32_t>::compare(h_C[i], h_ref[i], i, errors)) {
+        ++errors;
+      }
+    }
+  }
+
+  // cleanup
+  std::cout << "cleanup" << std::endl;
+  cleanup();
+
+  if (errors != 0) {
+    std::cout << "Found " << std::dec << errors << " errors!" << std::endl;
+    std::cout << "FAILED!" << std::endl;
+    return errors;
+  }
+
+  std::cout << "PASSED!" << std::endl;
+
+  return 0;
+}
\ No newline at end of file
diff --git a/tests/regression/sgemm8_sm/Makefile b/tests/regression/sgemm8_sm/Makefile
new file mode 100644
index 0000000..7be8e81
--- /dev/null
+++ b/tests/regression/sgemm8_sm/Makefile
@@ -0,0 +1,14 @@
+ROOT_DIR := $(realpath ../../..)
+include $(ROOT_DIR)/config.mk
+
+PROJECT := sgemm8_sm
+
+SRC_DIR := $(VORTEX_HOME)/tests/regression/$(PROJECT)
+
+SRCS := $(SRC_DIR)/main.cpp
+
+VX_SRCS := $(SRC_DIR)/kernel.cpp
+
+OPTS ?= -n16
+
+include ../common.mk
\ No newline at end of file
diff --git a/tests/regression/sgemm8_sm/common.h b/tests/regression/sgemm8_sm/common.h
new file mode 100644
index 0000000..80cb7ac
--- /dev/null
+++ b/tests/regression/sgemm8_sm/common.h
@@ -0,0 +1,15 @@
+#ifndef _COMMON_H_
+#define _COMMON_H_
+
+typedef struct {
+  uint32_t num_groups;
+  uint32_t group_size;
+  uint32_t size;
+  uint32_t tile_size;
+  uint64_t local_addr;
+  uint64_t A_addr;
+  uint64_t B_addr;
+  uint64_t C_addr;
+} kernel_arg_t;
+
+#endif
diff --git a/tests/regression/sgemm8_sm/kernel.cpp b/tests/regression/sgemm8_sm/kernel.cpp
new file mode 100644
index 0000000..fb559c0
--- /dev/null
+++ b/tests/regression/sgemm8_sm/kernel.cpp
@@ -0,0 +1,66 @@
+#include <stdint.h>
+#include <vx_intrinsics.h>
+#include <vx_spawn.h>
+#include <vx_print.h>
+#include "common.h"
+
+void kernel_body(int local_task_id, int group_id, int local_group_id, int warps_per_group, kernel_arg_t *arg) {
+	auto local_ptr = reinterpret_cast<int8_t*>(arg->local_addr);
+	auto A_ptr     = reinterpret_cast<int8_t*>(arg->A_addr);
+	auto B_ptr     = reinterpret_cast<int8_t*>(arg->B_addr);
+	auto C_ptr     = reinterpret_cast<int32_t*>(arg->C_addr);
+	auto size      = arg->size;
+  	auto tile_size = arg->tile_size;
+	auto num_groups = arg->num_groups;
+	auto group_size = arg->group_size;
+	auto num_tiles = size / tile_size;
+
+	// Determine row and column indices of the current subtask
+	auto l_row = local_task_id / tile_size;
+	auto l_col = local_task_id % tile_size;
+
+	// Determine row and column indices of the current task
+	auto g_row = (group_id / num_tiles) * tile_size + l_row;
+  	auto g_col = (group_id % num_tiles) * tile_size + l_col;
+
+	// Allocate local memory for the tile of matrix A & B
+	auto local_A = local_ptr + local_group_id * group_size * 2;
+	auto local_B = local_A + group_size;
+
+	int32_t sum(0);
+
+	// Loop over tiles
+	for (uint32_t k = 0; k < size; k += tile_size) {
+		// Load tile of matrix A & B to local memory
+		local_A[l_row * tile_size + l_col] = A_ptr[g_row * size + (k + l_col)];
+		local_B[l_row * tile_size + l_col] = B_ptr[(k + l_row) * size + g_col];
+
+		// Synchronize all warps in current group
+		vx_barrier(local_group_id * 2 + 0, warps_per_group);
+
+		for (uint32_t j = 0; j < tile_size; j += 4) {
+            uint32_t packed_a = *(uint32_t*)&local_A[l_row * tile_size + j];
+
+			uint8_t b0 = local_B[(j + 0) * tile_size + l_col]; 
+			uint8_t b1 = local_B[(j + 1) * tile_size + l_col];
+			uint8_t b2 = local_B[(j + 2) * tile_size + l_col];
+			uint8_t b3 = local_B[(j + 3) * tile_size + l_col];
+
+			uint32_t packed_b = ((uint32_t)b3 << 24) | ((uint32_t)b2 << 16) | ((uint32_t)b1 << 8) | (uint32_t)b0;
+
+			sum += vx_dot8(packed_a, packed_b);
+        }
+
+		// Synchronize all warps in current group
+		vx_barrier(local_group_id * 2 + 1, warps_per_group);
+	}
+
+	// Store the computed sum into the result matrix C
+	C_ptr[g_row * size + g_col] = sum;
+}
+ 
+int main() {
+	kernel_arg_t* arg = (kernel_arg_t*)csr_read(VX_CSR_MSCRATCH);
+	vx_spawn_task_groups(arg->num_groups, arg->group_size, (vx_spawn_task_groups_cb)kernel_body, arg);
+	return 0;
+}
diff --git a/tests/regression/sgemm8_sm/main.cpp b/tests/regression/sgemm8_sm/main.cpp
new file mode 100644
index 0000000..20b0279
--- /dev/null
+++ b/tests/regression/sgemm8_sm/main.cpp
@@ -0,0 +1,289 @@
+#include <iostream>
+#include <unistd.h>
+#include <string.h>
+#include <vector>
+#include <vortex.h>
+#include "common.h"
+
+#define FLOAT_ULP 6
+
+#define RT_CHECK(_expr)                                         \
+   do {                                                         \
+     int _ret = _expr;                                          \
+     if (0 == _ret)                                             \
+       break;                                                   \
+     printf("Error: '%s' returned %d!\n", #_expr, (int)_ret);   \
+	 cleanup();			                                              \
+     exit(-1);                                                  \
+   } while (false)
+
+///////////////////////////////////////////////////////////////////////////////
+
+template <typename Type>
+class Comparator {};
+
+template <>
+class Comparator<int8_t> {
+public:
+  static const char* type_str() {
+    return "int8";
+  }
+  static int generate() {
+    // static int q(1);
+    // return q++;
+    //return rand();
+    return (rand() * 256) / RAND_MAX;
+  }
+  static bool compare(int a, int b, int index, int errors) {
+    if (a != b) {
+      if (errors < 100) {
+        printf("*** error: [%d] expected=%d, actual=%d\n", index, a, b);
+      }
+      return false;
+    }
+    return true;
+  }
+};
+
+template <>
+class Comparator<int> {
+public:
+  static const char* type_str() {
+    return "integer";
+  }
+  static int generate() {
+    static int q(1);
+    return q++;
+    //return rand();
+  }
+  static bool compare(int a, int b, int index, int errors) {
+    if (a != b) {
+      if (errors < 100) {
+        printf("*** error: [%d] expected=%d, actual=%d\n", index, a, b);
+      }
+      return false;
+    }
+    return true;
+  }
+};
+
+template <>
+class Comparator<float> {
+private:
+  union Float_t { float f; int i; };
+public:
+  static const char* type_str() {
+    return "float";
+  }
+  static int generate() {
+    return static_cast<float>(rand()) / RAND_MAX;
+  }
+  static bool compare(float a, float b, int index, int errors) {
+    union fi_t { float f; int32_t i; };
+    fi_t fa, fb;
+    fa.f = a;
+    fb.f = b;
+    auto d = std::abs(fa.i - fb.i);
+    if (d > FLOAT_ULP) {
+      if (errors < 100) {
+        printf("*** error: [%d] expected=%f, actual=%f\n", index, a, b);
+      }
+      return false;
+    }
+    return true;
+  }
+};
+
+static void matmul_cpu(int32_t* out, const int8_t* A, const int8_t* B, uint32_t width, uint32_t height) {
+  for (uint32_t row = 0; row < height; ++row) {
+    for (uint32_t col = 0; col < width; ++col) {
+      int32_t sum(0);
+      for (uint32_t e = 0; e < width; ++e) {
+        int32_t a = A[row * width + e];
+        int32_t b = B[e * width + col];
+        int32_t c = a * b;
+        sum += c;
+        //printf("out[%d][%d]=%d; a=%d, b=%d, c=%d\n", row, col, sum, a, b, c);
+      }
+      out[row * width + col] = sum;
+    }
+  }
+}
+
+const char* kernel_file = "kernel.vxbin";
+uint32_t size = 16;
+uint32_t tile_size = 4;
+
+vx_device_h device = nullptr;
+vx_buffer_h A_buffer = nullptr;
+vx_buffer_h B_buffer = nullptr;
+vx_buffer_h C_buffer = nullptr;
+vx_buffer_h krnl_buffer = nullptr;
+vx_buffer_h args_buffer = nullptr;
+kernel_arg_t kernel_arg = {};
+
+static void show_usage() {
+   std::cout << "Vortex Test." << std::endl;
+   std::cout << "Usage: [-k: kernel] [-n matrix_size] [-t:tile_size] [-h: help]" << std::endl;
+}
+
+static void parse_args(int argc, char **argv) {
+  int c;
+  while ((c = getopt(argc, argv, "n:t:k:h?")) != -1) {
+    switch (c) {
+    case 'n':
+      size = atoi(optarg);
+      break;
+    case 't':
+      tile_size = atoi(optarg);
+      break;
+    case 'k':
+      kernel_file = optarg;
+      break;
+    case 'h':
+    case '?': {
+      show_usage();
+      exit(0);
+    } break;
+    default:
+      show_usage();
+      exit(-1);
+    }
+  }
+}
+
+void cleanup() {
+  if (device) {
+    vx_mem_free(A_buffer);
+    vx_mem_free(B_buffer);
+    vx_mem_free(C_buffer);
+    vx_mem_free(krnl_buffer);
+    vx_mem_free(args_buffer);
+    vx_dev_close(device);
+  }
+}
+
+int main(int argc, char *argv[]) {
+  // parse command arguments
+  parse_args(argc, argv);
+
+  if ((size / tile_size) * tile_size != size) {
+    printf("Error: matrix size %d must be a multiple of tile size %d\n", size, tile_size);
+    return -1;
+  }
+
+  std::srand(50);
+
+  // open device connection
+  std::cout << "open device connection" << std::endl;
+  RT_CHECK(vx_dev_open(&device));
+
+  uint32_t size_sq = size * size;
+  uint32_t buf_src_size = size_sq * sizeof(int8_t);
+  uint32_t buf_dst_size = size_sq * sizeof(int32_t);
+
+  uint32_t group_size = tile_size * tile_size;
+	uint32_t num_groups = (size * size) / group_size;
+  uint32_t local_mem = 2 * group_size * sizeof(int8_t);
+
+  std::cout << "data type: " << Comparator<int32_t>::type_str() << std::endl;
+  std::cout << "matrix size: " << size << "x" << size << std::endl;
+  std::cout << "tile size: " << tile_size << "x" << tile_size << std::endl;
+  std::cout << "group size: " << group_size << std::endl;
+  std::cout << "number of groups: " << num_groups << std::endl;
+  std::cout << "local memory: " << local_mem << " bytes" << std::endl;
+
+  kernel_arg.num_groups = num_groups;
+  kernel_arg.group_size = group_size;
+  kernel_arg.size = size;
+  kernel_arg.tile_size = tile_size;
+
+  // check work group occupancy
+  uint32_t max_barriers, max_localmem;
+  RT_CHECK(vx_check_occupancy(device, group_size, &max_barriers, &max_localmem));
+  RT_CHECK(max_barriers < 2);
+  RT_CHECK(max_localmem < local_mem);
+
+  // allocate device memory
+  std::cout << "allocate device memory" << std::endl;
+  RT_CHECK(vx_dev_caps(device, VX_CAPS_LOCAL_MEM_ADDR, &kernel_arg.local_addr));
+  RT_CHECK(vx_mem_alloc(device, buf_src_size, VX_MEM_READ, &A_buffer));
+  RT_CHECK(vx_mem_address(A_buffer, &kernel_arg.A_addr));
+  RT_CHECK(vx_mem_alloc(device, buf_src_size, VX_MEM_READ, &B_buffer));
+  RT_CHECK(vx_mem_address(B_buffer, &kernel_arg.B_addr));
+  RT_CHECK(vx_mem_alloc(device, buf_dst_size, VX_MEM_WRITE, &C_buffer));
+  RT_CHECK(vx_mem_address(C_buffer, &kernel_arg.C_addr));
+
+  std::cout << "local_addr=0x" << std::hex << kernel_arg.local_addr << std::endl;
+  std::cout << "A_addr=0x" << std::hex << kernel_arg.A_addr << std::endl;
+  std::cout << "B_addr=0x" << std::hex << kernel_arg.B_addr << std::endl;
+  std::cout << "C_addr=0x" << std::hex << kernel_arg.C_addr << std::endl;
+
+  // allocate host buffers
+  std::cout << "allocate host buffers" << std::endl;
+  std::vector<int8_t> h_A(size_sq);
+  std::vector<int8_t> h_B(size_sq);
+  std::vector<int32_t> h_C(size_sq);
+
+  // generate source data
+  for (uint32_t i = 0; i < size_sq; ++i) {
+    h_A[i] = Comparator<int8_t>::generate();
+    h_B[i] = Comparator<int8_t>::generate();
+  }
+
+  // upload source buffer0
+  std::cout << "upload source buffer0" << std::endl;
+  RT_CHECK(vx_copy_to_dev(A_buffer, h_A.data(), 0, buf_src_size));
+
+  // upload source buffer1
+  std::cout << "upload source buffer1" << std::endl;
+  RT_CHECK(vx_copy_to_dev(B_buffer, h_B.data(), 0, buf_src_size));
+
+  // upload program
+  std::cout << "upload program" << std::endl;
+  RT_CHECK(vx_upload_kernel_file(device, kernel_file, &krnl_buffer));
+
+  // upload kernel argument
+  std::cout << "upload kernel argument" << std::endl;
+  RT_CHECK(vx_upload_bytes(device, &kernel_arg, sizeof(kernel_arg_t), &args_buffer));
+
+  // start device
+  std::cout << "start device" << std::endl;
+  RT_CHECK(vx_start(device, krnl_buffer, args_buffer));
+
+  // wait for completion
+  std::cout << "wait for completion" << std::endl;
+  RT_CHECK(vx_ready_wait(device, VX_MAX_TIMEOUT));
+
+  // download destination buffer
+  std::cout << "download destination buffer" << std::endl;
+  RT_CHECK(vx_copy_from_dev(h_C.data(), C_buffer, 0, buf_dst_size));
+
+  // verify result
+  std::cout << "verify result" << std::endl;
+  int errors = 0;
+  {
+    std::vector<int32_t> h_ref(size_sq);
+    matmul_cpu(h_ref.data(), h_A.data(), h_B.data(), size, size);
+
+    for (uint32_t i = 0; i < h_ref.size(); ++i) {
+      if (!Comparator<int32_t>::compare(h_C[i], h_ref[i], i, errors)) {
+        ++errors;
+      }
+    }
+  }
+
+  // cleanup
+  std::cout << "cleanup" << std::endl;
+  cleanup();
+
+  if (errors != 0) {
+    std::cout << "Found " << std::dec << errors << " errors!" << std::endl;
+    std::cout << "FAILED!" << std::endl;
+    return errors;
+  }
+
+  std::cout << "PASSED!" << std::endl;
+
+  return 0;
+}
\ No newline at end of file
diff --git a/third_party/ramulator b/third_party/ramulator
--- a/third_party/ramulator
+++ b/third_party/ramulator
@@ -1 +1 @@
-Subproject commit 214f635845214adf030367939655d172ef0fed5f
+Subproject commit 214f635845214adf030367939655d172ef0fed5f-dirty
